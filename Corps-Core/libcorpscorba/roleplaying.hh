// This file is generated by omniidl2- omniORB_2_8. Do not edit.
#ifndef __roleplaying_hh__
#define __roleplaying_hh__

#ifndef USE_omniORB_logStream
#define USE_omniORB_logStream
#endif

#ifndef __CORBA_H_EXTERNAL_GUARD__
#define __CORBA_H_EXTERNAL_GUARD__
#include <omniORB2/CORBA.h>
#endif

#ifdef USE_stub_in_nt_dll
#ifndef USE_core_stub_in_nt_dll
#define USE_core_stub_in_nt_dll
#endif
#ifndef USE_dyn_stub_in_nt_dll
#define USE_dyn_stub_in_nt_dll
#endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif


_CORBA_MODULE RolePlaying

_CORBA_MODULE_BEG

  typedef char* Cookie;
  typedef CORBA::String_var Cookie_var;
#define RolePlaying_WrongCookie_IntfRepoID "IDL:RolePlaying/WrongCookie:1.0"

  class WrongCookie : public CORBA::UserException {
  public:

    
    WrongCookie() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    WrongCookie(const WrongCookie &);
    WrongCookie & operator=(const WrongCookie &);
    virtual ~WrongCookie();
    virtual void _raise();
    static WrongCookie* _downcast(CORBA::Exception* e);
    static const WrongCookie* _downcast(const CORBA::Exception* e);
    static WrongCookie* _narrow(CORBA::Exception* e);
    // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
    size_t NP_alignedSize(size_t initialoffset) const;
    void operator>>= (NetBufferedStream &) const;
    void operator<<= (NetBufferedStream &);
    void operator>>= (MemBufferedStream &) const;
    void operator<<= (MemBufferedStream &);
    static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
    static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
  private:
    virtual CORBA::Exception* _NP_duplicate() const;
    virtual const char* _NP_mostDerivedTypeId() const;
  };

  typedef char* MIMEType;
  typedef CORBA::String_var MIMEType_var;
  class MIMEList_var;

  class MIMEList : public _CORBA_Unbounded_Sequence__String {
  public:
    typedef MIMEList_var _var_type;
    inline MIMEList() {}
    inline MIMEList(const MIMEList& seq)
      : _CORBA_Unbounded_Sequence__String(seq) {}
    inline MIMEList(CORBA::ULong max)
      : _CORBA_Unbounded_Sequence__String(max) {}
    inline MIMEList(CORBA::ULong max, CORBA::ULong len, char** val, CORBA::Boolean rel=0)
      : _CORBA_Unbounded_Sequence__String(max, len, val, rel) {}
    inline MIMEList& operator = (const MIMEList& seq) {
      _CORBA_Unbounded_Sequence__String::operator=(seq);
      return *this;
    };
  };

  class MIMEList_out;

  class MIMEList_var {
  public:
    typedef MIMEList _Tseq;
    typedef MIMEList_var _T_var;

    inline MIMEList_var() : pd_seq(0) {}
    inline MIMEList_var(_Tseq* s) : pd_seq(s) {}
    inline MIMEList_var(const _T_var& sv) {
      if( sv.pd_seq ) {
        pd_seq = new _Tseq;
        *pd_seq = *sv.pd_seq;
      } else
        pd_seq = 0;
    }
    inline ~MIMEList_var() { if( pd_seq ) delete pd_seq; }

    inline _T_var& operator = (_Tseq* s) {
      if( pd_seq )  delete pd_seq;
      pd_seq = s;
      return *this;
    }
    inline _T_var& operator = (const _T_var& sv) {
      if( sv.pd_seq ) {
        if( !pd_seq )  pd_seq = new _Tseq;
        *pd_seq = *sv.pd_seq;
      } else if( pd_seq ) {
        delete pd_seq;
        pd_seq = 0;
      }
      return *this;
    }

    inline _CORBA_String_member operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
    inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
    inline operator _Tseq& () const { return *pd_seq; }
#else
    inline operator const _Tseq& () const { return *pd_seq; }
    inline operator _Tseq& () { return *pd_seq; }
#endif

    inline const _Tseq& in() const { return *pd_seq; }
    inline _Tseq& inout() { return *pd_seq; }
    inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
    inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

    friend class MIMEList_out;

  private:
    _Tseq* pd_seq;
  };

  class MIMEList_out {
  public:
    typedef MIMEList _Tseq;
    typedef MIMEList_var _T_var;

    inline MIMEList_out(_Tseq*& s) : _data(s) { _data = 0; }
    inline MIMEList_out(_T_var& sv)
      : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
    inline MIMEList_out(const MIMEList_out& s) : _data(s._data) { }
    inline MIMEList_out& operator=(const MIMEList_out& s) { _data = s._data; return *this; }
    inline MIMEList_out& operator=(_Tseq* s) { _data = s; return *this; }
    inline operator _Tseq*&() { return _data; }
    inline _Tseq*& ptr() { return _data; }
    inline _Tseq* operator->() { return _data; }
    inline _CORBA_String_member operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
    _Tseq*& _data;

  private:
    MIMEList_out();
    MIMEList_out operator=( const _T_var&);
  };

#define RolePlaying_UnknownMIMEType_IntfRepoID "IDL:RolePlaying/UnknownMIMEType:1.0"

  class UnknownMIMEType : public CORBA::UserException {
  public:

    CORBA::String_member type;
    
    UnknownMIMEType() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnknownMIMEType(const UnknownMIMEType &);
    UnknownMIMEType(const char*  _type);
    UnknownMIMEType & operator=(const UnknownMIMEType &);
    virtual ~UnknownMIMEType();
    virtual void _raise();
    static UnknownMIMEType* _downcast(CORBA::Exception* e);
    static const UnknownMIMEType* _downcast(const CORBA::Exception* e);
    static UnknownMIMEType* _narrow(CORBA::Exception* e);
    // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
    size_t NP_alignedSize(size_t initialoffset) const;
    void operator>>= (NetBufferedStream &) const;
    void operator<<= (NetBufferedStream &);
    void operator>>= (MemBufferedStream &) const;
    void operator<<= (MemBufferedStream &);
    static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
    static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
  private:
    virtual CORBA::Exception* _NP_duplicate() const;
    virtual const char* _NP_mostDerivedTypeId() const;
  };

#ifndef __RolePlaying_mProperty__
#define __RolePlaying_mProperty__
  class   Property;
  typedef Property* Property_ptr;
  typedef Property_ptr PropertyRef;

  class Property_Helper {
    public:
    static Property_ptr _nil();
    static CORBA::Boolean is_nil(Property_ptr p);
    static void release(Property_ptr p);
    static void duplicate(Property_ptr p);
    static size_t NP_alignedSize(Property_ptr obj,size_t initialoffset);
    static void marshalObjRef(Property_ptr obj,NetBufferedStream &s);
    static Property_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Property_ptr obj,MemBufferedStream &s);
    static Property_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Property,Property_Helper> Property_var;
  typedef _CORBA_ObjRef_OUT_arg<Property,Property_Helper > Property_out;

#endif
#define RolePlaying_Property_IntfRepoID "IDL:RolePlaying/Property:1.0"

  class Property : public virtual omniObject, public virtual CORBA::Object {
  public:

    virtual char* type() = 0;
    virtual CORBA::Any* o() = 0;
    typedef Property_var _var_type;
    typedef Property_ptr _ptr_type;
    static Property_ptr _duplicate(Property_ptr);
    static Property_ptr _narrow(CORBA::Object_ptr);
    static Property_ptr _nil();

    static inline size_t NP_alignedSize(Property_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Property_IntfRepoID,29,initialoffset);
    }

    static inline void marshalObjRef(Property_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Property_IntfRepoID,29,s);
    }

    static inline Property_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Property_IntfRepoID,s);
      Property_ptr _result = RolePlaying::Property::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Property_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Property_IntfRepoID,29,s);
    }

    static inline Property_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Property_IntfRepoID,s);
      Property_ptr _result = RolePlaying::Property::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Property() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Property_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Property();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Property(const Property&);
    Property &operator=(const Property&);
  };

  class _sk_Property :  public virtual Property {
  public:

    _sk_Property() {}
    _sk_Property(const omniORB::objectKey& k);
    virtual ~_sk_Property();
    Property_ptr _this() { return Property::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual char* type() = 0;
    virtual CORBA::Any* o() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Property::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Property (const _sk_Property&);
    _sk_Property &operator=(const _sk_Property&);
  };

  class _proxy_Property :  public virtual Property {
  public:

    _proxy_Property (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Property_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Property();
    virtual char* type();
    virtual CORBA::Any* o();

  protected:

    _proxy_Property () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Property::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Property (const _proxy_Property&);
    _proxy_Property &operator=(const _proxy_Property&);
  };

  class _nil_Property :   public virtual Property {
  public:
    _nil_Property() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Property();
    char* type() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    CORBA::Any* o() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      CORBA::Any * _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Property::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Property_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Property_proxyObjectFactory () {}
    virtual ~Property_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Property_ptr _nil() {
      if (!__nil_Property) {
        __nil_Property = new _nil_Property;
      }
      return __nil_Property;
    }
  private:
    static Property_ptr __nil_Property;
  };

  class PropertyList_var;

  class PropertyList : public _CORBA_Unbounded_Sequence_ObjRef<Property,_CORBA_ObjRef_Member<Property,Property_Helper>,Property_Helper > {
  public:
    typedef PropertyList_var _var_type;
    inline PropertyList() {}
    inline PropertyList(const PropertyList& seq)
      : _CORBA_Unbounded_Sequence_ObjRef<Property,_CORBA_ObjRef_Member<Property,Property_Helper>,Property_Helper >(seq) {}
    inline PropertyList(CORBA::ULong max)
      : _CORBA_Unbounded_Sequence_ObjRef<Property,_CORBA_ObjRef_Member<Property,Property_Helper>,Property_Helper >(max) {}
    inline PropertyList(CORBA::ULong max, CORBA::ULong len, Property_ptr* val, CORBA::Boolean rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef<Property,_CORBA_ObjRef_Member<Property,Property_Helper>,Property_Helper >(max, len, val, rel) {}
    inline PropertyList& operator = (const PropertyList& seq) {
      _CORBA_Unbounded_Sequence_ObjRef<Property,_CORBA_ObjRef_Member<Property,Property_Helper>,Property_Helper >::operator=(seq);
      return *this;
    };
  };

  class PropertyList_out;

  class PropertyList_var {
  public:
    typedef PropertyList _Tseq;
    typedef PropertyList_var _T_var;

    inline PropertyList_var() : pd_seq(0) {}
    inline PropertyList_var(_Tseq* s) : pd_seq(s) {}
    inline PropertyList_var(const _T_var& sv) {
      if( sv.pd_seq ) {
        pd_seq = new _Tseq;
        *pd_seq = *sv.pd_seq;
      } else
        pd_seq = 0;
    }
    inline ~PropertyList_var() { if( pd_seq ) delete pd_seq; }

    inline _T_var& operator = (_Tseq* s) {
      if( pd_seq )  delete pd_seq;
      pd_seq = s;
      return *this;
    }
    inline _T_var& operator = (const _T_var& sv) {
      if( sv.pd_seq ) {
        if( !pd_seq )  pd_seq = new _Tseq;
        *pd_seq = *sv.pd_seq;
      } else if( pd_seq ) {
        delete pd_seq;
        pd_seq = 0;
      }
      return *this;
    }

    inline _CORBA_ObjRef_Member<Property,Property_Helper> operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
    inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
    inline operator _Tseq& () const { return *pd_seq; }
#else
    inline operator const _Tseq& () const { return *pd_seq; }
    inline operator _Tseq& () { return *pd_seq; }
#endif

    inline const _Tseq& in() const { return *pd_seq; }
    inline _Tseq& inout() { return *pd_seq; }
    inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
    inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

    friend class PropertyList_out;

  private:
    _Tseq* pd_seq;
  };

  class PropertyList_out {
  public:
    typedef PropertyList _Tseq;
    typedef PropertyList_var _T_var;

    inline PropertyList_out(_Tseq*& s) : _data(s) { _data = 0; }
    inline PropertyList_out(_T_var& sv)
      : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
    inline PropertyList_out(const PropertyList_out& s) : _data(s._data) { }
    inline PropertyList_out& operator=(const PropertyList_out& s) { _data = s._data; return *this; }
    inline PropertyList_out& operator=(_Tseq* s) { _data = s; return *this; }
    inline operator _Tseq*&() { return _data; }
    inline _Tseq*& ptr() { return _data; }
    inline _Tseq* operator->() { return _data; }
    inline _CORBA_ObjRef_Member<Property,Property_Helper> operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
    _Tseq*& _data;

  private:
    PropertyList_out();
    PropertyList_out operator=( const _T_var&);
  };

#ifndef __RolePlaying_mThing__
#define __RolePlaying_mThing__
  class   Thing;
  typedef Thing* Thing_ptr;
  typedef Thing_ptr ThingRef;

  class Thing_Helper {
    public:
    static Thing_ptr _nil();
    static CORBA::Boolean is_nil(Thing_ptr p);
    static void release(Thing_ptr p);
    static void duplicate(Thing_ptr p);
    static size_t NP_alignedSize(Thing_ptr obj,size_t initialoffset);
    static void marshalObjRef(Thing_ptr obj,NetBufferedStream &s);
    static Thing_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Thing_ptr obj,MemBufferedStream &s);
    static Thing_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Thing,Thing_Helper> Thing_var;
  typedef _CORBA_ObjRef_OUT_arg<Thing,Thing_Helper > Thing_out;

#endif
#define RolePlaying_Thing_IntfRepoID "IDL:RolePlaying/Thing:1.0"

  class Thing : public virtual omniObject, public virtual CORBA::Object {
  public:

    virtual char* Name() = 0;
    virtual PropertyList* Properties() = 0;
    typedef Thing_var _var_type;
    typedef Thing_ptr _ptr_type;
    static Thing_ptr _duplicate(Thing_ptr);
    static Thing_ptr _narrow(CORBA::Object_ptr);
    static Thing_ptr _nil();

    static inline size_t NP_alignedSize(Thing_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Thing_IntfRepoID,26,initialoffset);
    }

    static inline void marshalObjRef(Thing_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Thing_IntfRepoID,26,s);
    }

    static inline Thing_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Thing_IntfRepoID,s);
      Thing_ptr _result = RolePlaying::Thing::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Thing_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Thing_IntfRepoID,26,s);
    }

    static inline Thing_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Thing_IntfRepoID,s);
      Thing_ptr _result = RolePlaying::Thing::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Thing() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Thing_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Thing();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Thing(const Thing&);
    Thing &operator=(const Thing&);
  };

  class _sk_Thing :  public virtual Thing {
  public:

    _sk_Thing() {}
    _sk_Thing(const omniORB::objectKey& k);
    virtual ~_sk_Thing();
    Thing_ptr _this() { return Thing::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual char* Name() = 0;
    virtual PropertyList* Properties() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Thing::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Thing (const _sk_Thing&);
    _sk_Thing &operator=(const _sk_Thing&);
  };

  class _proxy_Thing :  public virtual Thing {
  public:

    _proxy_Thing (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Thing_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Thing();
    virtual char* Name();
    virtual PropertyList* Properties();

  protected:

    _proxy_Thing () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Thing::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Thing (const _proxy_Thing&);
    _proxy_Thing &operator=(const _proxy_Thing&);
  };

  class _nil_Thing :   public virtual Thing {
  public:
    _nil_Thing() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Thing();
    char* Name() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    PropertyList* Properties() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      PropertyList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Thing::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Thing_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Thing_proxyObjectFactory () {}
    virtual ~Thing_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Thing_ptr _nil() {
      if (!__nil_Thing) {
        __nil_Thing = new _nil_Thing;
      }
      return __nil_Thing;
    }
  private:
    static Thing_ptr __nil_Thing;
  };

  class ThingList_var;

  class ThingList : public _CORBA_Unbounded_Sequence_ObjRef<Thing,_CORBA_ObjRef_Member<Thing,Thing_Helper>,Thing_Helper > {
  public:
    typedef ThingList_var _var_type;
    inline ThingList() {}
    inline ThingList(const ThingList& seq)
      : _CORBA_Unbounded_Sequence_ObjRef<Thing,_CORBA_ObjRef_Member<Thing,Thing_Helper>,Thing_Helper >(seq) {}
    inline ThingList(CORBA::ULong max)
      : _CORBA_Unbounded_Sequence_ObjRef<Thing,_CORBA_ObjRef_Member<Thing,Thing_Helper>,Thing_Helper >(max) {}
    inline ThingList(CORBA::ULong max, CORBA::ULong len, Thing_ptr* val, CORBA::Boolean rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef<Thing,_CORBA_ObjRef_Member<Thing,Thing_Helper>,Thing_Helper >(max, len, val, rel) {}
    inline ThingList& operator = (const ThingList& seq) {
      _CORBA_Unbounded_Sequence_ObjRef<Thing,_CORBA_ObjRef_Member<Thing,Thing_Helper>,Thing_Helper >::operator=(seq);
      return *this;
    };
  };

  class ThingList_out;

  class ThingList_var {
  public:
    typedef ThingList _Tseq;
    typedef ThingList_var _T_var;

    inline ThingList_var() : pd_seq(0) {}
    inline ThingList_var(_Tseq* s) : pd_seq(s) {}
    inline ThingList_var(const _T_var& sv) {
      if( sv.pd_seq ) {
        pd_seq = new _Tseq;
        *pd_seq = *sv.pd_seq;
      } else
        pd_seq = 0;
    }
    inline ~ThingList_var() { if( pd_seq ) delete pd_seq; }

    inline _T_var& operator = (_Tseq* s) {
      if( pd_seq )  delete pd_seq;
      pd_seq = s;
      return *this;
    }
    inline _T_var& operator = (const _T_var& sv) {
      if( sv.pd_seq ) {
        if( !pd_seq )  pd_seq = new _Tseq;
        *pd_seq = *sv.pd_seq;
      } else if( pd_seq ) {
        delete pd_seq;
        pd_seq = 0;
      }
      return *this;
    }

    inline _CORBA_ObjRef_Member<Thing,Thing_Helper> operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
    inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
    inline operator _Tseq& () const { return *pd_seq; }
#else
    inline operator const _Tseq& () const { return *pd_seq; }
    inline operator _Tseq& () { return *pd_seq; }
#endif

    inline const _Tseq& in() const { return *pd_seq; }
    inline _Tseq& inout() { return *pd_seq; }
    inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
    inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

    friend class ThingList_out;

  private:
    _Tseq* pd_seq;
  };

  class ThingList_out {
  public:
    typedef ThingList _Tseq;
    typedef ThingList_var _T_var;

    inline ThingList_out(_Tseq*& s) : _data(s) { _data = 0; }
    inline ThingList_out(_T_var& sv)
      : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
    inline ThingList_out(const ThingList_out& s) : _data(s._data) { }
    inline ThingList_out& operator=(const ThingList_out& s) { _data = s._data; return *this; }
    inline ThingList_out& operator=(_Tseq* s) { _data = s; return *this; }
    inline operator _Tseq*&() { return _data; }
    inline _Tseq*& ptr() { return _data; }
    inline _Tseq* operator->() { return _data; }
    inline _CORBA_ObjRef_Member<Thing,Thing_Helper> operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
    _Tseq*& _data;

  private:
    ThingList_out();
    ThingList_out operator=( const _T_var&);
  };

#ifndef __RolePlaying_mContainer__
#define __RolePlaying_mContainer__
  class   Container;
  typedef Container* Container_ptr;
  typedef Container_ptr ContainerRef;

  class Container_Helper {
    public:
    static Container_ptr _nil();
    static CORBA::Boolean is_nil(Container_ptr p);
    static void release(Container_ptr p);
    static void duplicate(Container_ptr p);
    static size_t NP_alignedSize(Container_ptr obj,size_t initialoffset);
    static void marshalObjRef(Container_ptr obj,NetBufferedStream &s);
    static Container_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Container_ptr obj,MemBufferedStream &s);
    static Container_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Container,Container_Helper> Container_var;
  typedef _CORBA_ObjRef_OUT_arg<Container,Container_Helper > Container_out;

#endif
#define RolePlaying_Container_IntfRepoID "IDL:RolePlaying/Container:1.0"

  class Container :  public virtual Thing {
  public:

    virtual ThingList* containing() = 0;
    typedef Container_var _var_type;
    typedef Container_ptr _ptr_type;
    static Container_ptr _duplicate(Container_ptr);
    static Container_ptr _narrow(CORBA::Object_ptr);
    static Container_ptr _nil();

    static inline size_t NP_alignedSize(Container_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Container_IntfRepoID,30,initialoffset);
    }

    static inline void marshalObjRef(Container_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Container_IntfRepoID,30,s);
    }

    static inline Container_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Container_IntfRepoID,s);
      Container_ptr _result = RolePlaying::Container::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Container_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Container_IntfRepoID,30,s);
    }

    static inline Container_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Container_IntfRepoID,s);
      Container_ptr _result = RolePlaying::Container::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Container() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Container_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Container();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Container(const Container&);
    Container &operator=(const Container&);
  };

  class _sk_Container :  public virtual _sk_Thing, public virtual Container {
  public:

    _sk_Container() {}
    _sk_Container(const omniORB::objectKey& k);
    virtual ~_sk_Container();
    Container_ptr _this() { return Container::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual ThingList* containing() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Container::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Container (const _sk_Container&);
    _sk_Container &operator=(const _sk_Container&);
  };

  class _proxy_Container :  public virtual _proxy_Thing, public virtual Container {
  public:

    _proxy_Container (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Container_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Container();
    virtual ThingList* containing();

  protected:

    _proxy_Container () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Container::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Container (const _proxy_Container&);
    _proxy_Container &operator=(const _proxy_Container&);
  };

  class _nil_Container :  public virtual _nil_Thing,   public virtual Container {
  public:
    _nil_Container() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Container();
    ThingList* containing() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      ThingList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Container::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Container_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Container_proxyObjectFactory () {}
    virtual ~Container_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Container_ptr _nil() {
      if (!__nil_Container) {
        __nil_Container = new _nil_Container;
      }
      return __nil_Container;
    }
  private:
    static Container_ptr __nil_Container;
  };

#ifndef __RolePlaying_mCharacter__
#define __RolePlaying_mCharacter__
  class   Character;
  typedef Character* Character_ptr;
  typedef Character_ptr CharacterRef;

  class Character_Helper {
    public:
    static Character_ptr _nil();
    static CORBA::Boolean is_nil(Character_ptr p);
    static void release(Character_ptr p);
    static void duplicate(Character_ptr p);
    static size_t NP_alignedSize(Character_ptr obj,size_t initialoffset);
    static void marshalObjRef(Character_ptr obj,NetBufferedStream &s);
    static Character_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Character_ptr obj,MemBufferedStream &s);
    static Character_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Character,Character_Helper> Character_var;
  typedef _CORBA_ObjRef_OUT_arg<Character,Character_Helper > Character_out;

#endif
#define RolePlaying_Character_IntfRepoID "IDL:RolePlaying/Character:1.0"

  class Character :  public virtual Thing {
  public:

    virtual ThingList* Inventory() = 0;
    typedef Character_var _var_type;
    typedef Character_ptr _ptr_type;
    static Character_ptr _duplicate(Character_ptr);
    static Character_ptr _narrow(CORBA::Object_ptr);
    static Character_ptr _nil();

    static inline size_t NP_alignedSize(Character_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Character_IntfRepoID,30,initialoffset);
    }

    static inline void marshalObjRef(Character_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Character_IntfRepoID,30,s);
    }

    static inline Character_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Character_IntfRepoID,s);
      Character_ptr _result = RolePlaying::Character::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Character_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Character_IntfRepoID,30,s);
    }

    static inline Character_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Character_IntfRepoID,s);
      Character_ptr _result = RolePlaying::Character::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Character() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Character_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Character();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Character(const Character&);
    Character &operator=(const Character&);
  };

  class _sk_Character :  public virtual _sk_Thing, public virtual Character {
  public:

    _sk_Character() {}
    _sk_Character(const omniORB::objectKey& k);
    virtual ~_sk_Character();
    Character_ptr _this() { return Character::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual ThingList* Inventory() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Character::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Character (const _sk_Character&);
    _sk_Character &operator=(const _sk_Character&);
  };

  class _proxy_Character :  public virtual _proxy_Thing, public virtual Character {
  public:

    _proxy_Character (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Character_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Character();
    virtual ThingList* Inventory();

  protected:

    _proxy_Character () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Character::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Character (const _proxy_Character&);
    _proxy_Character &operator=(const _proxy_Character&);
  };

  class _nil_Character :  public virtual _nil_Thing,   public virtual Character {
  public:
    _nil_Character() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Character();
    ThingList* Inventory() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      ThingList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Character::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Character_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Character_proxyObjectFactory () {}
    virtual ~Character_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Character_ptr _nil() {
      if (!__nil_Character) {
        __nil_Character = new _nil_Character;
      }
      return __nil_Character;
    }
  private:
    static Character_ptr __nil_Character;
  };

  typedef char* MapSet;
  typedef CORBA::String_var MapSet_var;
#ifndef __RolePlaying_mMap__
#define __RolePlaying_mMap__
  class   Map;
  typedef Map* Map_ptr;
  typedef Map_ptr MapRef;

  class Map_Helper {
    public:
    static Map_ptr _nil();
    static CORBA::Boolean is_nil(Map_ptr p);
    static void release(Map_ptr p);
    static void duplicate(Map_ptr p);
    static size_t NP_alignedSize(Map_ptr obj,size_t initialoffset);
    static void marshalObjRef(Map_ptr obj,NetBufferedStream &s);
    static Map_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Map_ptr obj,MemBufferedStream &s);
    static Map_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Map,Map_Helper> Map_var;
  typedef _CORBA_ObjRef_OUT_arg<Map,Map_Helper > Map_out;

#endif
#define RolePlaying_Map_IntfRepoID "IDL:RolePlaying/Map:1.0"

  class Map : public virtual omniObject, public virtual CORBA::Object {
  public:

    struct Position_s {
      typedef _CORBA_ConstrType_Fix_Var<Position_s> _var_type;
      CORBA::Short xpos;
      CORBA::Short ypos;
      
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
    };

    typedef Position_s::_var_type Position_s_var;

    typedef _CORBA_ConstrType_Fix_OUT_arg< Position_s,Position_s_var > Position_s_out;

    typedef Position_s Position;
    typedef Position_s_var Position_var;
    typedef Position_s_out Position_out;
    typedef CORBA::UShort FieldType;
    static _core_attr const CORBA::UShort FT_Unknown _init_in_cldecl_(  = 0 );
    static _core_attr const CORBA::UShort FT_Nothing _init_in_cldecl_(  = 1 );
    static _core_attr const CORBA::UShort FT_Unseen _init_in_cldecl_(  = 2 );
    static _core_attr const CORBA::UShort FT_User _init_in_cldecl_(  = 256 );
    typedef CORBA::UShort FieldFlags;
    static _core_attr const CORBA::UShort FF_Invisible _init_in_cldecl_(  = 1 );
    typedef CORBA::UShort ModifierType;
    static _core_attr const CORBA::UShort MT_Unknown _init_in_cldecl_(  = 0 );
    static _core_attr const CORBA::UShort MT_User _init_in_cldecl_(  = 256 );
    typedef CORBA::UShort ModifierFlags;
    static _core_attr const CORBA::UShort MF_HasObject _init_in_cldecl_(  = 1 );
    struct Modifier {
      typedef _CORBA_ConstrType_Variable_Var<Modifier> _var_type;
      ModifierType type;
      ModifierFlags flags;
      CORBA::Object_member o;
      
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
    };

    typedef Modifier::_var_type Modifier_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< Modifier,Modifier_var > Modifier_out;

    class Modifiers_var;

    class Modifiers : public _CORBA_Unbounded_Sequence<Modifier > {
    public:
      typedef Modifiers_var _var_type;
      inline Modifiers() {}
      inline Modifiers(const Modifiers& seq)
        : _CORBA_Unbounded_Sequence<Modifier >(seq) {}
      inline Modifiers(CORBA::ULong max)
        : _CORBA_Unbounded_Sequence<Modifier >(max) {}
      inline Modifiers(CORBA::ULong max, CORBA::ULong len, Modifier* val, CORBA::Boolean rel=0)
        : _CORBA_Unbounded_Sequence<Modifier >(max, len, val, rel) {}
      inline Modifiers& operator = (const Modifiers& seq) {
        _CORBA_Unbounded_Sequence<Modifier >::operator=(seq);
        return *this;
      };
    };

    class Modifiers_out;

    class Modifiers_var {
    public:
      typedef Modifiers _Tseq;
      typedef Modifiers_var _T_var;

      inline Modifiers_var() : pd_seq(0) {}
      inline Modifiers_var(_Tseq* s) : pd_seq(s) {}
      inline Modifiers_var(const _T_var& sv) {
        if( sv.pd_seq ) {
          pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else
          pd_seq = 0;
      }
      inline ~Modifiers_var() { if( pd_seq ) delete pd_seq; }

      inline _T_var& operator = (_Tseq* s) {
        if( pd_seq )  delete pd_seq;
        pd_seq = s;
        return *this;
      }
      inline _T_var& operator = (const _T_var& sv) {
        if( sv.pd_seq ) {
          if( !pd_seq )  pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else if( pd_seq ) {
          delete pd_seq;
          pd_seq = 0;
        }
        return *this;
      }

      inline Modifier& operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
      inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
      inline operator _Tseq& () const { return *pd_seq; }
#else
      inline operator const _Tseq& () const { return *pd_seq; }
      inline operator _Tseq& () { return *pd_seq; }
#endif

      inline const _Tseq& in() const { return *pd_seq; }
      inline _Tseq& inout() { return *pd_seq; }
      inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
      inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

      friend class Modifiers_out;

    private:
      _Tseq* pd_seq;
    };

    class Modifiers_out {
    public:
      typedef Modifiers _Tseq;
      typedef Modifiers_var _T_var;

      inline Modifiers_out(_Tseq*& s) : _data(s) { _data = 0; }
      inline Modifiers_out(_T_var& sv)
        : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
      inline Modifiers_out(const Modifiers_out& s) : _data(s._data) { }
      inline Modifiers_out& operator=(const Modifiers_out& s) { _data = s._data; return *this; }
      inline Modifiers_out& operator=(_Tseq* s) { _data = s; return *this; }
      inline operator _Tseq*&() { return _data; }
      inline _Tseq*& ptr() { return _data; }
      inline _Tseq* operator->() { return _data; }
      inline Modifier& operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
      _Tseq*& _data;

    private:
      Modifiers_out();
      Modifiers_out operator=( const _T_var&);
    };

    struct Field {
      typedef _CORBA_ConstrType_Variable_Var<Field> _var_type;
      Position pos;
      FieldType type;
      FieldFlags flags;
      Modifiers ModifierList;
      
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
    };

    typedef Field::_var_type Field_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< Field,Field_var > Field_out;

    class Fields_var;

    class Fields : public _CORBA_Unbounded_Sequence<Field > {
    public:
      typedef Fields_var _var_type;
      inline Fields() {}
      inline Fields(const Fields& seq)
        : _CORBA_Unbounded_Sequence<Field >(seq) {}
      inline Fields(CORBA::ULong max)
        : _CORBA_Unbounded_Sequence<Field >(max) {}
      inline Fields(CORBA::ULong max, CORBA::ULong len, Field* val, CORBA::Boolean rel=0)
        : _CORBA_Unbounded_Sequence<Field >(max, len, val, rel) {}
      inline Fields& operator = (const Fields& seq) {
        _CORBA_Unbounded_Sequence<Field >::operator=(seq);
        return *this;
      };
    };

    class Fields_out;

    class Fields_var {
    public:
      typedef Fields _Tseq;
      typedef Fields_var _T_var;

      inline Fields_var() : pd_seq(0) {}
      inline Fields_var(_Tseq* s) : pd_seq(s) {}
      inline Fields_var(const _T_var& sv) {
        if( sv.pd_seq ) {
          pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else
          pd_seq = 0;
      }
      inline ~Fields_var() { if( pd_seq ) delete pd_seq; }

      inline _T_var& operator = (_Tseq* s) {
        if( pd_seq )  delete pd_seq;
        pd_seq = s;
        return *this;
      }
      inline _T_var& operator = (const _T_var& sv) {
        if( sv.pd_seq ) {
          if( !pd_seq )  pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else if( pd_seq ) {
          delete pd_seq;
          pd_seq = 0;
        }
        return *this;
      }

      inline Field& operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
      inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
      inline operator _Tseq& () const { return *pd_seq; }
#else
      inline operator const _Tseq& () const { return *pd_seq; }
      inline operator _Tseq& () { return *pd_seq; }
#endif

      inline const _Tseq& in() const { return *pd_seq; }
      inline _Tseq& inout() { return *pd_seq; }
      inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
      inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

      friend class Fields_out;

    private:
      _Tseq* pd_seq;
    };

    class Fields_out {
    public:
      typedef Fields _Tseq;
      typedef Fields_var _T_var;

      inline Fields_out(_Tseq*& s) : _data(s) { _data = 0; }
      inline Fields_out(_T_var& sv)
        : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
      inline Fields_out(const Fields_out& s) : _data(s._data) { }
      inline Fields_out& operator=(const Fields_out& s) { _data = s._data; return *this; }
      inline Fields_out& operator=(_Tseq* s) { _data = s; return *this; }
      inline operator _Tseq*&() { return _data; }
      inline _Tseq*& ptr() { return _data; }
      inline _Tseq* operator->() { return _data; }
      inline Field& operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
      _Tseq*& _data;

    private:
      Fields_out();
      Fields_out operator=( const _T_var&);
    };

    struct PackedField {
      typedef _CORBA_ConstrType_Variable_Var<PackedField> _var_type;
      FieldType type;
      FieldFlags flags;
      Modifiers ModifierList;
      
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
    };

    typedef PackedField::_var_type PackedField_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PackedField,PackedField_var > PackedField_out;

    class PackedFields_var;

    class PackedFields : public _CORBA_Unbounded_Sequence<PackedField > {
    public:
      typedef PackedFields_var _var_type;
      inline PackedFields() {}
      inline PackedFields(const PackedFields& seq)
        : _CORBA_Unbounded_Sequence<PackedField >(seq) {}
      inline PackedFields(CORBA::ULong max)
        : _CORBA_Unbounded_Sequence<PackedField >(max) {}
      inline PackedFields(CORBA::ULong max, CORBA::ULong len, PackedField* val, CORBA::Boolean rel=0)
        : _CORBA_Unbounded_Sequence<PackedField >(max, len, val, rel) {}
      inline PackedFields& operator = (const PackedFields& seq) {
        _CORBA_Unbounded_Sequence<PackedField >::operator=(seq);
        return *this;
      };
    };

    class PackedFields_out;

    class PackedFields_var {
    public:
      typedef PackedFields _Tseq;
      typedef PackedFields_var _T_var;

      inline PackedFields_var() : pd_seq(0) {}
      inline PackedFields_var(_Tseq* s) : pd_seq(s) {}
      inline PackedFields_var(const _T_var& sv) {
        if( sv.pd_seq ) {
          pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else
          pd_seq = 0;
      }
      inline ~PackedFields_var() { if( pd_seq ) delete pd_seq; }

      inline _T_var& operator = (_Tseq* s) {
        if( pd_seq )  delete pd_seq;
        pd_seq = s;
        return *this;
      }
      inline _T_var& operator = (const _T_var& sv) {
        if( sv.pd_seq ) {
          if( !pd_seq )  pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else if( pd_seq ) {
          delete pd_seq;
          pd_seq = 0;
        }
        return *this;
      }

      inline PackedField& operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
      inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
      inline operator _Tseq& () const { return *pd_seq; }
#else
      inline operator const _Tseq& () const { return *pd_seq; }
      inline operator _Tseq& () { return *pd_seq; }
#endif

      inline const _Tseq& in() const { return *pd_seq; }
      inline _Tseq& inout() { return *pd_seq; }
      inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
      inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

      friend class PackedFields_out;

    private:
      _Tseq* pd_seq;
    };

    class PackedFields_out {
    public:
      typedef PackedFields _Tseq;
      typedef PackedFields_var _T_var;

      inline PackedFields_out(_Tseq*& s) : _data(s) { _data = 0; }
      inline PackedFields_out(_T_var& sv)
        : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
      inline PackedFields_out(const PackedFields_out& s) : _data(s._data) { }
      inline PackedFields_out& operator=(const PackedFields_out& s) { _data = s._data; return *this; }
      inline PackedFields_out& operator=(_Tseq* s) { _data = s; return *this; }
      inline operator _Tseq*&() { return _data; }
      inline _Tseq*& ptr() { return _data; }
      inline _Tseq* operator->() { return _data; }
      inline PackedField& operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
      _Tseq*& _data;

    private:
      PackedFields_out();
      PackedFields_out operator=( const _T_var&);
    };

    typedef Map_var _var_type;
    typedef Map_ptr _ptr_type;
    static Map_ptr _duplicate(Map_ptr);
    static Map_ptr _narrow(CORBA::Object_ptr);
    static Map_ptr _nil();

    static inline size_t NP_alignedSize(Map_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Map_IntfRepoID,24,initialoffset);
    }

    static inline void marshalObjRef(Map_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Map_IntfRepoID,24,s);
    }

    static inline Map_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Map_IntfRepoID,s);
      Map_ptr _result = RolePlaying::Map::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Map_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Map_IntfRepoID,24,s);
    }

    static inline Map_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Map_IntfRepoID,s);
      Map_ptr _result = RolePlaying::Map::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Map() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Map_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Map();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Map(const Map&);
    Map &operator=(const Map&);
  };

  class _sk_Map :  public virtual Map {
  public:

    _sk_Map() {}
    _sk_Map(const omniORB::objectKey& k);
    virtual ~_sk_Map();
    Map_ptr _this() { return Map::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Map::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Map (const _sk_Map&);
    _sk_Map &operator=(const _sk_Map&);
  };

  class _proxy_Map :  public virtual Map {
  public:

    _proxy_Map (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Map_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Map();

  protected:

    _proxy_Map () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Map::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Map (const _proxy_Map&);
    _proxy_Map &operator=(const _proxy_Map&);
  };

  class _nil_Map :   public virtual Map {
  public:
    _nil_Map() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Map();
  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Map::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Map_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Map_proxyObjectFactory () {}
    virtual ~Map_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Map_ptr _nil() {
      if (!__nil_Map) {
        __nil_Map = new _nil_Map;
      }
      return __nil_Map;
    }
  private:
    static Map_ptr __nil_Map;
  };

#ifndef __RolePlaying_mServerHandler__
#define __RolePlaying_mServerHandler__
  class   ServerHandler;
  typedef ServerHandler* ServerHandler_ptr;
  typedef ServerHandler_ptr ServerHandlerRef;

  class ServerHandler_Helper {
    public:
    static ServerHandler_ptr _nil();
    static CORBA::Boolean is_nil(ServerHandler_ptr p);
    static void release(ServerHandler_ptr p);
    static void duplicate(ServerHandler_ptr p);
    static size_t NP_alignedSize(ServerHandler_ptr obj,size_t initialoffset);
    static void marshalObjRef(ServerHandler_ptr obj,NetBufferedStream &s);
    static ServerHandler_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(ServerHandler_ptr obj,MemBufferedStream &s);
    static ServerHandler_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<ServerHandler,ServerHandler_Helper> ServerHandler_var;
  typedef _CORBA_ObjRef_OUT_arg<ServerHandler,ServerHandler_Helper > ServerHandler_out;

#endif
#define RolePlaying_ServerHandler_IntfRepoID "IDL:RolePlaying/ServerHandler:1.0"

  class ServerHandler : public virtual omniObject, public virtual CORBA::Object {
  public:

    typedef ServerHandler_var _var_type;
    typedef ServerHandler_ptr _ptr_type;
    static ServerHandler_ptr _duplicate(ServerHandler_ptr);
    static ServerHandler_ptr _narrow(CORBA::Object_ptr);
    static ServerHandler_ptr _nil();

    static inline size_t NP_alignedSize(ServerHandler_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_ServerHandler_IntfRepoID,34,initialoffset);
    }

    static inline void marshalObjRef(ServerHandler_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_ServerHandler_IntfRepoID,34,s);
    }

    static inline ServerHandler_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_ServerHandler_IntfRepoID,s);
      ServerHandler_ptr _result = RolePlaying::ServerHandler::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(ServerHandler_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_ServerHandler_IntfRepoID,34,s);
    }

    static inline ServerHandler_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_ServerHandler_IntfRepoID,s);
      ServerHandler_ptr _result = RolePlaying::ServerHandler::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    ServerHandler() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_ServerHandler_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~ServerHandler();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    ServerHandler(const ServerHandler&);
    ServerHandler &operator=(const ServerHandler&);
  };

  class _sk_ServerHandler :  public virtual ServerHandler {
  public:

    _sk_ServerHandler() {}
    _sk_ServerHandler(const omniORB::objectKey& k);
    virtual ~_sk_ServerHandler();
    ServerHandler_ptr _this() { return ServerHandler::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return ServerHandler::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_ServerHandler (const _sk_ServerHandler&);
    _sk_ServerHandler &operator=(const _sk_ServerHandler&);
  };

  class _proxy_ServerHandler :  public virtual ServerHandler {
  public:

    _proxy_ServerHandler (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_ServerHandler_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_ServerHandler();

  protected:

    _proxy_ServerHandler () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return ServerHandler::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_ServerHandler (const _proxy_ServerHandler&);
    _proxy_ServerHandler &operator=(const _proxy_ServerHandler&);
  };

  class _nil_ServerHandler :   public virtual ServerHandler {
  public:
    _nil_ServerHandler() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_ServerHandler();
  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return ServerHandler::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class ServerHandler_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    ServerHandler_proxyObjectFactory () {}
    virtual ~ServerHandler_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static ServerHandler_ptr _nil() {
      if (!__nil_ServerHandler) {
        __nil_ServerHandler = new _nil_ServerHandler;
      }
      return __nil_ServerHandler;
    }
  private:
    static ServerHandler_ptr __nil_ServerHandler;
  };

#ifndef __RolePlaying_mSH__Receiver__
#define __RolePlaying_mSH__Receiver__
  class   SH_Receiver;
  typedef SH_Receiver* SH_Receiver_ptr;
  typedef SH_Receiver_ptr SH_ReceiverRef;

  class SH_Receiver_Helper {
    public:
    static SH_Receiver_ptr _nil();
    static CORBA::Boolean is_nil(SH_Receiver_ptr p);
    static void release(SH_Receiver_ptr p);
    static void duplicate(SH_Receiver_ptr p);
    static size_t NP_alignedSize(SH_Receiver_ptr obj,size_t initialoffset);
    static void marshalObjRef(SH_Receiver_ptr obj,NetBufferedStream &s);
    static SH_Receiver_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(SH_Receiver_ptr obj,MemBufferedStream &s);
    static SH_Receiver_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<SH_Receiver,SH_Receiver_Helper> SH_Receiver_var;
  typedef _CORBA_ObjRef_OUT_arg<SH_Receiver,SH_Receiver_Helper > SH_Receiver_out;

#endif
#define RolePlaying_SH_Receiver_IntfRepoID "IDL:RolePlaying/SH_Receiver:1.0"

  class SH_Receiver :  public virtual ServerHandler {
  public:

    virtual void transmit(const char*  what, const CORBA::Any & data,CORBA::Context_ptr ctxt) = 0;
    typedef SH_Receiver_var _var_type;
    typedef SH_Receiver_ptr _ptr_type;
    static SH_Receiver_ptr _duplicate(SH_Receiver_ptr);
    static SH_Receiver_ptr _narrow(CORBA::Object_ptr);
    static SH_Receiver_ptr _nil();

    static inline size_t NP_alignedSize(SH_Receiver_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_SH_Receiver_IntfRepoID,32,initialoffset);
    }

    static inline void marshalObjRef(SH_Receiver_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_SH_Receiver_IntfRepoID,32,s);
    }

    static inline SH_Receiver_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_SH_Receiver_IntfRepoID,s);
      SH_Receiver_ptr _result = RolePlaying::SH_Receiver::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(SH_Receiver_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_SH_Receiver_IntfRepoID,32,s);
    }

    static inline SH_Receiver_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_SH_Receiver_IntfRepoID,s);
      SH_Receiver_ptr _result = RolePlaying::SH_Receiver::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    SH_Receiver() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_SH_Receiver_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~SH_Receiver();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    SH_Receiver(const SH_Receiver&);
    SH_Receiver &operator=(const SH_Receiver&);
  };

  class _sk_SH_Receiver :  public virtual _sk_ServerHandler, public virtual SH_Receiver {
  public:

    _sk_SH_Receiver() {}
    _sk_SH_Receiver(const omniORB::objectKey& k);
    virtual ~_sk_SH_Receiver();
    SH_Receiver_ptr _this() { return SH_Receiver::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual void transmit(const char*  what, const CORBA::Any & data,CORBA::Context_ptr ctxt) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return SH_Receiver::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_SH_Receiver (const _sk_SH_Receiver&);
    _sk_SH_Receiver &operator=(const _sk_SH_Receiver&);
  };

  class _proxy_SH_Receiver :  public virtual _proxy_ServerHandler, public virtual SH_Receiver {
  public:

    _proxy_SH_Receiver (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_SH_Receiver_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_SH_Receiver();
    virtual void transmit(const char*  what, const CORBA::Any & data,CORBA::Context_ptr ctxt);

  protected:

    _proxy_SH_Receiver () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return SH_Receiver::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_SH_Receiver (const _proxy_SH_Receiver&);
    _proxy_SH_Receiver &operator=(const _proxy_SH_Receiver&);
  };

  class _nil_SH_Receiver :  public virtual _nil_ServerHandler,   public virtual SH_Receiver {
  public:
    _nil_SH_Receiver() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_SH_Receiver();
    void transmit(const char*  what, const CORBA::Any & data,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return SH_Receiver::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class SH_Receiver_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    SH_Receiver_proxyObjectFactory () {}
    virtual ~SH_Receiver_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static SH_Receiver_ptr _nil() {
      if (!__nil_SH_Receiver) {
        __nil_SH_Receiver = new _nil_SH_Receiver;
      }
      return __nil_SH_Receiver;
    }
  private:
    static SH_Receiver_ptr __nil_SH_Receiver;
  };

#ifndef __RolePlaying_mClientHandler__
#define __RolePlaying_mClientHandler__
  class   ClientHandler;
  typedef ClientHandler* ClientHandler_ptr;
  typedef ClientHandler_ptr ClientHandlerRef;

  class ClientHandler_Helper {
    public:
    static ClientHandler_ptr _nil();
    static CORBA::Boolean is_nil(ClientHandler_ptr p);
    static void release(ClientHandler_ptr p);
    static void duplicate(ClientHandler_ptr p);
    static size_t NP_alignedSize(ClientHandler_ptr obj,size_t initialoffset);
    static void marshalObjRef(ClientHandler_ptr obj,NetBufferedStream &s);
    static ClientHandler_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(ClientHandler_ptr obj,MemBufferedStream &s);
    static ClientHandler_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<ClientHandler,ClientHandler_Helper> ClientHandler_var;
  typedef _CORBA_ObjRef_OUT_arg<ClientHandler,ClientHandler_Helper > ClientHandler_out;

#endif
#define RolePlaying_ClientHandler_IntfRepoID "IDL:RolePlaying/ClientHandler:1.0"

  class ClientHandler : public virtual omniObject, public virtual CORBA::Object {
  public:

#define RolePlaying_ClientHandler_NoSuchHandler_IntfRepoID "IDL:RolePlaying/ClientHandler/NoSuchHandler:1.0"

    class NoSuchHandler : public CORBA::UserException {
    public:

      
      NoSuchHandler() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NoSuchHandler(const NoSuchHandler &);
      NoSuchHandler & operator=(const NoSuchHandler &);
      virtual ~NoSuchHandler();
      virtual void _raise();
      static NoSuchHandler* _downcast(CORBA::Exception* e);
      static const NoSuchHandler* _downcast(const CORBA::Exception* e);
      static NoSuchHandler* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

#define RolePlaying_ClientHandler_HandlerNotActive_IntfRepoID "IDL:RolePlaying/ClientHandler/HandlerNotActive:1.0"

    class HandlerNotActive : public CORBA::UserException {
    public:

      
      HandlerNotActive() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      HandlerNotActive(const HandlerNotActive &);
      HandlerNotActive & operator=(const HandlerNotActive &);
      virtual ~HandlerNotActive();
      virtual void _raise();
      static HandlerNotActive* _downcast(CORBA::Exception* e);
      static const HandlerNotActive* _downcast(const CORBA::Exception* e);
      static HandlerNotActive* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

    virtual void enable() = 0;
    virtual void disable() = 0;
    typedef ClientHandler_var _var_type;
    typedef ClientHandler_ptr _ptr_type;
    static ClientHandler_ptr _duplicate(ClientHandler_ptr);
    static ClientHandler_ptr _narrow(CORBA::Object_ptr);
    static ClientHandler_ptr _nil();

    static inline size_t NP_alignedSize(ClientHandler_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_ClientHandler_IntfRepoID,34,initialoffset);
    }

    static inline void marshalObjRef(ClientHandler_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_ClientHandler_IntfRepoID,34,s);
    }

    static inline ClientHandler_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_ClientHandler_IntfRepoID,s);
      ClientHandler_ptr _result = RolePlaying::ClientHandler::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(ClientHandler_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_ClientHandler_IntfRepoID,34,s);
    }

    static inline ClientHandler_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_ClientHandler_IntfRepoID,s);
      ClientHandler_ptr _result = RolePlaying::ClientHandler::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    ClientHandler() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_ClientHandler_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~ClientHandler();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    ClientHandler(const ClientHandler&);
    ClientHandler &operator=(const ClientHandler&);
  };

  class _sk_ClientHandler :  public virtual ClientHandler {
  public:

    _sk_ClientHandler() {}
    _sk_ClientHandler(const omniORB::objectKey& k);
    virtual ~_sk_ClientHandler();
    ClientHandler_ptr _this() { return ClientHandler::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual void enable() = 0;
    virtual void disable() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return ClientHandler::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_ClientHandler (const _sk_ClientHandler&);
    _sk_ClientHandler &operator=(const _sk_ClientHandler&);
  };

  class _proxy_ClientHandler :  public virtual ClientHandler {
  public:

    _proxy_ClientHandler (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_ClientHandler_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_ClientHandler();
    virtual void enable();
    virtual void disable();

  protected:

    _proxy_ClientHandler () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return ClientHandler::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_ClientHandler (const _proxy_ClientHandler&);
    _proxy_ClientHandler &operator=(const _proxy_ClientHandler&);
  };

  class _nil_ClientHandler :   public virtual ClientHandler {
  public:
    _nil_ClientHandler() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_ClientHandler();
    void enable(){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void disable(){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return ClientHandler::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class ClientHandler_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    ClientHandler_proxyObjectFactory () {}
    virtual ~ClientHandler_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static ClientHandler_ptr _nil() {
      if (!__nil_ClientHandler) {
        __nil_ClientHandler = new _nil_ClientHandler;
      }
      return __nil_ClientHandler;
    }
  private:
    static ClientHandler_ptr __nil_ClientHandler;
  };

#ifndef __RolePlaying_mCH__Display__
#define __RolePlaying_mCH__Display__
  class   CH_Display;
  typedef CH_Display* CH_Display_ptr;
  typedef CH_Display_ptr CH_DisplayRef;

  class CH_Display_Helper {
    public:
    static CH_Display_ptr _nil();
    static CORBA::Boolean is_nil(CH_Display_ptr p);
    static void release(CH_Display_ptr p);
    static void duplicate(CH_Display_ptr p);
    static size_t NP_alignedSize(CH_Display_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_Display_ptr obj,NetBufferedStream &s);
    static CH_Display_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_Display_ptr obj,MemBufferedStream &s);
    static CH_Display_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_Display,CH_Display_Helper> CH_Display_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_Display,CH_Display_Helper > CH_Display_out;

#endif
#define RolePlaying_CH_Display_IntfRepoID "IDL:RolePlaying/CH_Display:1.0"

  class CH_Display :  public virtual ClientHandler {
  public:

    virtual MIMEList* SupportedMIME() = 0;
    virtual void show() = 0;
    virtual void play(CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt) = 0;
    virtual void clear() = 0;
    typedef CH_Display_var _var_type;
    typedef CH_Display_ptr _ptr_type;
    static CH_Display_ptr _duplicate(CH_Display_ptr);
    static CH_Display_ptr _narrow(CORBA::Object_ptr);
    static CH_Display_ptr _nil();

    static inline size_t NP_alignedSize(CH_Display_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_Display_IntfRepoID,31,initialoffset);
    }

    static inline void marshalObjRef(CH_Display_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Display_IntfRepoID,31,s);
    }

    static inline CH_Display_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Display_IntfRepoID,s);
      CH_Display_ptr _result = RolePlaying::CH_Display::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_Display_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Display_IntfRepoID,31,s);
    }

    static inline CH_Display_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Display_IntfRepoID,s);
      CH_Display_ptr _result = RolePlaying::CH_Display::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_Display() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_Display_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_Display();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_Display(const CH_Display&);
    CH_Display &operator=(const CH_Display&);
  };

  class _sk_CH_Display :  public virtual _sk_ClientHandler, public virtual CH_Display {
  public:

    _sk_CH_Display() {}
    _sk_CH_Display(const omniORB::objectKey& k);
    virtual ~_sk_CH_Display();
    CH_Display_ptr _this() { return CH_Display::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual MIMEList* SupportedMIME() = 0;
    virtual void show() = 0;
    virtual void play(CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt) = 0;
    virtual void clear() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Display::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_Display (const _sk_CH_Display&);
    _sk_CH_Display &operator=(const _sk_CH_Display&);
  };

  class _proxy_CH_Display :  public virtual _proxy_ClientHandler, public virtual CH_Display {
  public:

    _proxy_CH_Display (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_Display_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_Display();
    virtual MIMEList* SupportedMIME();
    virtual void show();
    virtual void play(CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt);
    virtual void clear();

  protected:

    _proxy_CH_Display () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_Display::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_Display (const _proxy_CH_Display&);
    _proxy_CH_Display &operator=(const _proxy_CH_Display&);
  };

  class _nil_CH_Display :  public virtual _nil_ClientHandler,   public virtual CH_Display {
  public:
    _nil_CH_Display() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_Display();
    MIMEList* SupportedMIME() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      MIMEList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

    void show(){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void play(CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void clear(){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Display::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_Display_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_Display_proxyObjectFactory () {}
    virtual ~CH_Display_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_Display_ptr _nil() {
      if (!__nil_CH_Display) {
        __nil_CH_Display = new _nil_CH_Display;
      }
      return __nil_CH_Display;
    }
  private:
    static CH_Display_ptr __nil_CH_Display;
  };

#ifndef __RolePlaying_mCH__Popup__
#define __RolePlaying_mCH__Popup__
  class   CH_Popup;
  typedef CH_Popup* CH_Popup_ptr;
  typedef CH_Popup_ptr CH_PopupRef;

  class CH_Popup_Helper {
    public:
    static CH_Popup_ptr _nil();
    static CORBA::Boolean is_nil(CH_Popup_ptr p);
    static void release(CH_Popup_ptr p);
    static void duplicate(CH_Popup_ptr p);
    static size_t NP_alignedSize(CH_Popup_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_Popup_ptr obj,NetBufferedStream &s);
    static CH_Popup_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_Popup_ptr obj,MemBufferedStream &s);
    static CH_Popup_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_Popup,CH_Popup_Helper> CH_Popup_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_Popup,CH_Popup_Helper > CH_Popup_out;

#endif
#define RolePlaying_CH_Popup_IntfRepoID "IDL:RolePlaying/CH_Popup:1.0"

  class CH_Popup :  public virtual ClientHandler {
  public:

    virtual MIMEList* SupportedMIME() = 0;
    virtual void show(const char*  mime, CORBA::Octet  data,CORBA::Context_ptr ctxt) = 0;
    virtual void play(const char*  mime, CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt) = 0;
    typedef CH_Popup_var _var_type;
    typedef CH_Popup_ptr _ptr_type;
    static CH_Popup_ptr _duplicate(CH_Popup_ptr);
    static CH_Popup_ptr _narrow(CORBA::Object_ptr);
    static CH_Popup_ptr _nil();

    static inline size_t NP_alignedSize(CH_Popup_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_Popup_IntfRepoID,29,initialoffset);
    }

    static inline void marshalObjRef(CH_Popup_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Popup_IntfRepoID,29,s);
    }

    static inline CH_Popup_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Popup_IntfRepoID,s);
      CH_Popup_ptr _result = RolePlaying::CH_Popup::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_Popup_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Popup_IntfRepoID,29,s);
    }

    static inline CH_Popup_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Popup_IntfRepoID,s);
      CH_Popup_ptr _result = RolePlaying::CH_Popup::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_Popup() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_Popup_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_Popup();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_Popup(const CH_Popup&);
    CH_Popup &operator=(const CH_Popup&);
  };

  class _sk_CH_Popup :  public virtual _sk_ClientHandler, public virtual CH_Popup {
  public:

    _sk_CH_Popup() {}
    _sk_CH_Popup(const omniORB::objectKey& k);
    virtual ~_sk_CH_Popup();
    CH_Popup_ptr _this() { return CH_Popup::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual MIMEList* SupportedMIME() = 0;
    virtual void show(const char*  mime, CORBA::Octet  data,CORBA::Context_ptr ctxt) = 0;
    virtual void play(const char*  mime, CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Popup::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_Popup (const _sk_CH_Popup&);
    _sk_CH_Popup &operator=(const _sk_CH_Popup&);
  };

  class _proxy_CH_Popup :  public virtual _proxy_ClientHandler, public virtual CH_Popup {
  public:

    _proxy_CH_Popup (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_Popup_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_Popup();
    virtual MIMEList* SupportedMIME();
    virtual void show(const char*  mime, CORBA::Octet  data,CORBA::Context_ptr ctxt);
    virtual void play(const char*  mime, CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt);

  protected:

    _proxy_CH_Popup () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_Popup::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_Popup (const _proxy_CH_Popup&);
    _proxy_CH_Popup &operator=(const _proxy_CH_Popup&);
  };

  class _nil_CH_Popup :  public virtual _nil_ClientHandler,   public virtual CH_Popup {
  public:
    _nil_CH_Popup() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_Popup();
    MIMEList* SupportedMIME() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      MIMEList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

    void show(const char*  mime, CORBA::Octet  data,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void play(const char*  mime, CORBA::Octet  data, CORBA::Boolean  repeat,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Popup::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_Popup_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_Popup_proxyObjectFactory () {}
    virtual ~CH_Popup_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_Popup_ptr _nil() {
      if (!__nil_CH_Popup) {
        __nil_CH_Popup = new _nil_CH_Popup;
      }
      return __nil_CH_Popup;
    }
  private:
    static CH_Popup_ptr __nil_CH_Popup;
  };

#ifndef __RolePlaying_mCH__History__
#define __RolePlaying_mCH__History__
  class   CH_History;
  typedef CH_History* CH_History_ptr;
  typedef CH_History_ptr CH_HistoryRef;

  class CH_History_Helper {
    public:
    static CH_History_ptr _nil();
    static CORBA::Boolean is_nil(CH_History_ptr p);
    static void release(CH_History_ptr p);
    static void duplicate(CH_History_ptr p);
    static size_t NP_alignedSize(CH_History_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_History_ptr obj,NetBufferedStream &s);
    static CH_History_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_History_ptr obj,MemBufferedStream &s);
    static CH_History_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_History,CH_History_Helper> CH_History_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_History,CH_History_Helper > CH_History_out;

#endif
#define RolePlaying_CH_History_IntfRepoID "IDL:RolePlaying/CH_History:1.0"

  class CH_History :  public virtual ClientHandler {
  public:

    virtual void append_text(const char*  text,CORBA::Context_ptr ctxt) = 0;
    virtual void clear(CORBA::Context_ptr ctxt) = 0;
    typedef CH_History_var _var_type;
    typedef CH_History_ptr _ptr_type;
    static CH_History_ptr _duplicate(CH_History_ptr);
    static CH_History_ptr _narrow(CORBA::Object_ptr);
    static CH_History_ptr _nil();

    static inline size_t NP_alignedSize(CH_History_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_History_IntfRepoID,31,initialoffset);
    }

    static inline void marshalObjRef(CH_History_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_History_IntfRepoID,31,s);
    }

    static inline CH_History_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_History_IntfRepoID,s);
      CH_History_ptr _result = RolePlaying::CH_History::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_History_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_History_IntfRepoID,31,s);
    }

    static inline CH_History_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_History_IntfRepoID,s);
      CH_History_ptr _result = RolePlaying::CH_History::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_History() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_History_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_History();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_History(const CH_History&);
    CH_History &operator=(const CH_History&);
  };

  class _sk_CH_History :  public virtual _sk_ClientHandler, public virtual CH_History {
  public:

    _sk_CH_History() {}
    _sk_CH_History(const omniORB::objectKey& k);
    virtual ~_sk_CH_History();
    CH_History_ptr _this() { return CH_History::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual void append_text(const char*  text,CORBA::Context_ptr ctxt) = 0;
    virtual void clear(CORBA::Context_ptr ctxt) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_History::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_History (const _sk_CH_History&);
    _sk_CH_History &operator=(const _sk_CH_History&);
  };

  class _proxy_CH_History :  public virtual _proxy_ClientHandler, public virtual CH_History {
  public:

    _proxy_CH_History (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_History_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_History();
    virtual void append_text(const char*  text,CORBA::Context_ptr ctxt);
    virtual void clear(CORBA::Context_ptr ctxt);

  protected:

    _proxy_CH_History () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_History::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_History (const _proxy_CH_History&);
    _proxy_CH_History &operator=(const _proxy_CH_History&);
  };

  class _nil_CH_History :  public virtual _nil_ClientHandler,   public virtual CH_History {
  public:
    _nil_CH_History() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_History();
    void append_text(const char*  text,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void clear(CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_History::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_History_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_History_proxyObjectFactory () {}
    virtual ~CH_History_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_History_ptr _nil() {
      if (!__nil_CH_History) {
        __nil_CH_History = new _nil_CH_History;
      }
      return __nil_CH_History;
    }
  private:
    static CH_History_ptr __nil_CH_History;
  };

#ifndef __RolePlaying_mCH__InputLine__
#define __RolePlaying_mCH__InputLine__
  class   CH_InputLine;
  typedef CH_InputLine* CH_InputLine_ptr;
  typedef CH_InputLine_ptr CH_InputLineRef;

  class CH_InputLine_Helper {
    public:
    static CH_InputLine_ptr _nil();
    static CORBA::Boolean is_nil(CH_InputLine_ptr p);
    static void release(CH_InputLine_ptr p);
    static void duplicate(CH_InputLine_ptr p);
    static size_t NP_alignedSize(CH_InputLine_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_InputLine_ptr obj,NetBufferedStream &s);
    static CH_InputLine_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_InputLine_ptr obj,MemBufferedStream &s);
    static CH_InputLine_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_InputLine,CH_InputLine_Helper> CH_InputLine_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_InputLine,CH_InputLine_Helper > CH_InputLine_out;

#endif
#define RolePlaying_CH_InputLine_IntfRepoID "IDL:RolePlaying/CH_InputLine:1.0"

  class CH_InputLine :  public virtual ClientHandler {
  public:

    virtual void sensitive(SH_Receiver_ptr  dest,CORBA::Context_ptr ctxt) = 0;
    virtual void resensitive(CORBA::Context_ptr ctxt) = 0;
    virtual void unsensitive(CORBA::Context_ptr ctxt) = 0;
    virtual CORBA::Boolean auto_disable() = 0;
    virtual void auto_disable(CORBA::Boolean) = 0;
    typedef CH_InputLine_var _var_type;
    typedef CH_InputLine_ptr _ptr_type;
    static CH_InputLine_ptr _duplicate(CH_InputLine_ptr);
    static CH_InputLine_ptr _narrow(CORBA::Object_ptr);
    static CH_InputLine_ptr _nil();

    static inline size_t NP_alignedSize(CH_InputLine_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_InputLine_IntfRepoID,33,initialoffset);
    }

    static inline void marshalObjRef(CH_InputLine_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_InputLine_IntfRepoID,33,s);
    }

    static inline CH_InputLine_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_InputLine_IntfRepoID,s);
      CH_InputLine_ptr _result = RolePlaying::CH_InputLine::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_InputLine_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_InputLine_IntfRepoID,33,s);
    }

    static inline CH_InputLine_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_InputLine_IntfRepoID,s);
      CH_InputLine_ptr _result = RolePlaying::CH_InputLine::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_InputLine() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_InputLine_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_InputLine();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_InputLine(const CH_InputLine&);
    CH_InputLine &operator=(const CH_InputLine&);
  };

  class _sk_CH_InputLine :  public virtual _sk_ClientHandler, public virtual CH_InputLine {
  public:

    _sk_CH_InputLine() {}
    _sk_CH_InputLine(const omniORB::objectKey& k);
    virtual ~_sk_CH_InputLine();
    CH_InputLine_ptr _this() { return CH_InputLine::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual void sensitive(SH_Receiver_ptr  dest,CORBA::Context_ptr ctxt) = 0;
    virtual void resensitive(CORBA::Context_ptr ctxt) = 0;
    virtual void unsensitive(CORBA::Context_ptr ctxt) = 0;
    virtual CORBA::Boolean auto_disable() = 0;
    virtual void auto_disable(CORBA::Boolean) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_InputLine::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_InputLine (const _sk_CH_InputLine&);
    _sk_CH_InputLine &operator=(const _sk_CH_InputLine&);
  };

  class _proxy_CH_InputLine :  public virtual _proxy_ClientHandler, public virtual CH_InputLine {
  public:

    _proxy_CH_InputLine (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_InputLine_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_InputLine();
    virtual void sensitive(SH_Receiver_ptr  dest,CORBA::Context_ptr ctxt);
    virtual void resensitive(CORBA::Context_ptr ctxt);
    virtual void unsensitive(CORBA::Context_ptr ctxt);
    virtual CORBA::Boolean auto_disable();
    virtual void auto_disable(CORBA::Boolean);

  protected:

    _proxy_CH_InputLine () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_InputLine::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_InputLine (const _proxy_CH_InputLine&);
    _proxy_CH_InputLine &operator=(const _proxy_CH_InputLine&);
  };

  class _nil_CH_InputLine :  public virtual _nil_ClientHandler,   public virtual CH_InputLine {
  public:
    _nil_CH_InputLine() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_InputLine();
    void sensitive(SH_Receiver_ptr  dest,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void resensitive(CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void unsensitive(CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    CORBA::Boolean auto_disable() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      CORBA::Boolean _0RL_result = 0;
      return _0RL_result;
#endif
    }

    void auto_disable(CORBA::Boolean _value) {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_InputLine::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_InputLine_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_InputLine_proxyObjectFactory () {}
    virtual ~CH_InputLine_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_InputLine_ptr _nil() {
      if (!__nil_CH_InputLine) {
        __nil_CH_InputLine = new _nil_CH_InputLine;
      }
      return __nil_CH_InputLine;
    }
  private:
    static CH_InputLine_ptr __nil_CH_InputLine;
  };

#ifndef __RolePlaying_mCH__Requester__
#define __RolePlaying_mCH__Requester__
  class   CH_Requester;
  typedef CH_Requester* CH_Requester_ptr;
  typedef CH_Requester_ptr CH_RequesterRef;

  class CH_Requester_Helper {
    public:
    static CH_Requester_ptr _nil();
    static CORBA::Boolean is_nil(CH_Requester_ptr p);
    static void release(CH_Requester_ptr p);
    static void duplicate(CH_Requester_ptr p);
    static size_t NP_alignedSize(CH_Requester_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_Requester_ptr obj,NetBufferedStream &s);
    static CH_Requester_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_Requester_ptr obj,MemBufferedStream &s);
    static CH_Requester_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_Requester,CH_Requester_Helper> CH_Requester_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_Requester,CH_Requester_Helper > CH_Requester_out;

#endif
#define RolePlaying_CH_Requester_IntfRepoID "IDL:RolePlaying/CH_Requester:1.0"

  class CH_Requester :  public virtual ClientHandler {
  public:

    virtual char*  request_string(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt) = 0;
    virtual char*  request_text(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt) = 0;
    typedef CH_Requester_var _var_type;
    typedef CH_Requester_ptr _ptr_type;
    static CH_Requester_ptr _duplicate(CH_Requester_ptr);
    static CH_Requester_ptr _narrow(CORBA::Object_ptr);
    static CH_Requester_ptr _nil();

    static inline size_t NP_alignedSize(CH_Requester_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_Requester_IntfRepoID,33,initialoffset);
    }

    static inline void marshalObjRef(CH_Requester_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Requester_IntfRepoID,33,s);
    }

    static inline CH_Requester_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Requester_IntfRepoID,s);
      CH_Requester_ptr _result = RolePlaying::CH_Requester::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_Requester_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Requester_IntfRepoID,33,s);
    }

    static inline CH_Requester_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Requester_IntfRepoID,s);
      CH_Requester_ptr _result = RolePlaying::CH_Requester::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_Requester() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_Requester_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_Requester();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_Requester(const CH_Requester&);
    CH_Requester &operator=(const CH_Requester&);
  };

  class _sk_CH_Requester :  public virtual _sk_ClientHandler, public virtual CH_Requester {
  public:

    _sk_CH_Requester() {}
    _sk_CH_Requester(const omniORB::objectKey& k);
    virtual ~_sk_CH_Requester();
    CH_Requester_ptr _this() { return CH_Requester::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual char*  request_string(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt) = 0;
    virtual char*  request_text(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Requester::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_Requester (const _sk_CH_Requester&);
    _sk_CH_Requester &operator=(const _sk_CH_Requester&);
  };

  class _proxy_CH_Requester :  public virtual _proxy_ClientHandler, public virtual CH_Requester {
  public:

    _proxy_CH_Requester (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_Requester_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_Requester();
    virtual char*  request_string(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt);
    virtual char*  request_text(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt);

  protected:

    _proxy_CH_Requester () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_Requester::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_Requester (const _proxy_CH_Requester&);
    _proxy_CH_Requester &operator=(const _proxy_CH_Requester&);
  };

  class _nil_CH_Requester :  public virtual _nil_ClientHandler,   public virtual CH_Requester {
  public:
    _nil_CH_Requester() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_Requester();
    char*  request_string(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    char*  request_text(const char*  what, CORBA::Boolean  cancelable,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Requester::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_Requester_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_Requester_proxyObjectFactory () {}
    virtual ~CH_Requester_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_Requester_ptr _nil() {
      if (!__nil_CH_Requester) {
        __nil_CH_Requester = new _nil_CH_Requester;
      }
      return __nil_CH_Requester;
    }
  private:
    static CH_Requester_ptr __nil_CH_Requester;
  };

#ifndef __RolePlaying_mCH__CharacterList__
#define __RolePlaying_mCH__CharacterList__
  class   CH_CharacterList;
  typedef CH_CharacterList* CH_CharacterList_ptr;
  typedef CH_CharacterList_ptr CH_CharacterListRef;

  class CH_CharacterList_Helper {
    public:
    static CH_CharacterList_ptr _nil();
    static CORBA::Boolean is_nil(CH_CharacterList_ptr p);
    static void release(CH_CharacterList_ptr p);
    static void duplicate(CH_CharacterList_ptr p);
    static size_t NP_alignedSize(CH_CharacterList_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_CharacterList_ptr obj,NetBufferedStream &s);
    static CH_CharacterList_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_CharacterList_ptr obj,MemBufferedStream &s);
    static CH_CharacterList_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_CharacterList,CH_CharacterList_Helper> CH_CharacterList_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_CharacterList,CH_CharacterList_Helper > CH_CharacterList_out;

#endif
#define RolePlaying_CH_CharacterList_IntfRepoID "IDL:RolePlaying/CH_CharacterList:1.0"

  class CH_CharacterList :  public virtual ClientHandler {
  public:

    typedef CH_CharacterList_var _var_type;
    typedef CH_CharacterList_ptr _ptr_type;
    static CH_CharacterList_ptr _duplicate(CH_CharacterList_ptr);
    static CH_CharacterList_ptr _narrow(CORBA::Object_ptr);
    static CH_CharacterList_ptr _nil();

    static inline size_t NP_alignedSize(CH_CharacterList_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_CharacterList_IntfRepoID,37,initialoffset);
    }

    static inline void marshalObjRef(CH_CharacterList_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_CharacterList_IntfRepoID,37,s);
    }

    static inline CH_CharacterList_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_CharacterList_IntfRepoID,s);
      CH_CharacterList_ptr _result = RolePlaying::CH_CharacterList::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_CharacterList_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_CharacterList_IntfRepoID,37,s);
    }

    static inline CH_CharacterList_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_CharacterList_IntfRepoID,s);
      CH_CharacterList_ptr _result = RolePlaying::CH_CharacterList::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_CharacterList() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_CharacterList_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_CharacterList();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_CharacterList(const CH_CharacterList&);
    CH_CharacterList &operator=(const CH_CharacterList&);
  };

  class _sk_CH_CharacterList :  public virtual _sk_ClientHandler, public virtual CH_CharacterList {
  public:

    _sk_CH_CharacterList() {}
    _sk_CH_CharacterList(const omniORB::objectKey& k);
    virtual ~_sk_CH_CharacterList();
    CH_CharacterList_ptr _this() { return CH_CharacterList::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_CharacterList::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_CharacterList (const _sk_CH_CharacterList&);
    _sk_CH_CharacterList &operator=(const _sk_CH_CharacterList&);
  };

  class _proxy_CH_CharacterList :  public virtual _proxy_ClientHandler, public virtual CH_CharacterList {
  public:

    _proxy_CH_CharacterList (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_CharacterList_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_CharacterList();

  protected:

    _proxy_CH_CharacterList () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_CharacterList::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_CharacterList (const _proxy_CH_CharacterList&);
    _proxy_CH_CharacterList &operator=(const _proxy_CH_CharacterList&);
  };

  class _nil_CH_CharacterList :  public virtual _nil_ClientHandler,   public virtual CH_CharacterList {
  public:
    _nil_CH_CharacterList() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_CharacterList();
  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_CharacterList::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_CharacterList_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_CharacterList_proxyObjectFactory () {}
    virtual ~CH_CharacterList_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_CharacterList_ptr _nil() {
      if (!__nil_CH_CharacterList) {
        __nil_CH_CharacterList = new _nil_CH_CharacterList;
      }
      return __nil_CH_CharacterList;
    }
  private:
    static CH_CharacterList_ptr __nil_CH_CharacterList;
  };

#ifndef __RolePlaying_mCH__Compass__
#define __RolePlaying_mCH__Compass__
  class   CH_Compass;
  typedef CH_Compass* CH_Compass_ptr;
  typedef CH_Compass_ptr CH_CompassRef;

  class CH_Compass_Helper {
    public:
    static CH_Compass_ptr _nil();
    static CORBA::Boolean is_nil(CH_Compass_ptr p);
    static void release(CH_Compass_ptr p);
    static void duplicate(CH_Compass_ptr p);
    static size_t NP_alignedSize(CH_Compass_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_Compass_ptr obj,NetBufferedStream &s);
    static CH_Compass_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_Compass_ptr obj,MemBufferedStream &s);
    static CH_Compass_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_Compass,CH_Compass_Helper> CH_Compass_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_Compass,CH_Compass_Helper > CH_Compass_out;

#endif
#define RolePlaying_CH_Compass_IntfRepoID "IDL:RolePlaying/CH_Compass:1.0"

  class CH_Compass :  public virtual ClientHandler {
  public:

    typedef CH_Compass_var _var_type;
    typedef CH_Compass_ptr _ptr_type;
    static CH_Compass_ptr _duplicate(CH_Compass_ptr);
    static CH_Compass_ptr _narrow(CORBA::Object_ptr);
    static CH_Compass_ptr _nil();

    static inline size_t NP_alignedSize(CH_Compass_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_Compass_IntfRepoID,31,initialoffset);
    }

    static inline void marshalObjRef(CH_Compass_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Compass_IntfRepoID,31,s);
    }

    static inline CH_Compass_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Compass_IntfRepoID,s);
      CH_Compass_ptr _result = RolePlaying::CH_Compass::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_Compass_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Compass_IntfRepoID,31,s);
    }

    static inline CH_Compass_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Compass_IntfRepoID,s);
      CH_Compass_ptr _result = RolePlaying::CH_Compass::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_Compass() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_Compass_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_Compass();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_Compass(const CH_Compass&);
    CH_Compass &operator=(const CH_Compass&);
  };

  class _sk_CH_Compass :  public virtual _sk_ClientHandler, public virtual CH_Compass {
  public:

    _sk_CH_Compass() {}
    _sk_CH_Compass(const omniORB::objectKey& k);
    virtual ~_sk_CH_Compass();
    CH_Compass_ptr _this() { return CH_Compass::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Compass::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_Compass (const _sk_CH_Compass&);
    _sk_CH_Compass &operator=(const _sk_CH_Compass&);
  };

  class _proxy_CH_Compass :  public virtual _proxy_ClientHandler, public virtual CH_Compass {
  public:

    _proxy_CH_Compass (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_Compass_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_Compass();

  protected:

    _proxy_CH_Compass () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_Compass::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_Compass (const _proxy_CH_Compass&);
    _proxy_CH_Compass &operator=(const _proxy_CH_Compass&);
  };

  class _nil_CH_Compass :  public virtual _nil_ClientHandler,   public virtual CH_Compass {
  public:
    _nil_CH_Compass() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_Compass();
  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Compass::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_Compass_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_Compass_proxyObjectFactory () {}
    virtual ~CH_Compass_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_Compass_ptr _nil() {
      if (!__nil_CH_Compass) {
        __nil_CH_Compass = new _nil_CH_Compass;
      }
      return __nil_CH_Compass;
    }
  private:
    static CH_Compass_ptr __nil_CH_Compass;
  };

#ifndef __RolePlaying_mCH__Sound__
#define __RolePlaying_mCH__Sound__
  class   CH_Sound;
  typedef CH_Sound* CH_Sound_ptr;
  typedef CH_Sound_ptr CH_SoundRef;

  class CH_Sound_Helper {
    public:
    static CH_Sound_ptr _nil();
    static CORBA::Boolean is_nil(CH_Sound_ptr p);
    static void release(CH_Sound_ptr p);
    static void duplicate(CH_Sound_ptr p);
    static size_t NP_alignedSize(CH_Sound_ptr obj,size_t initialoffset);
    static void marshalObjRef(CH_Sound_ptr obj,NetBufferedStream &s);
    static CH_Sound_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(CH_Sound_ptr obj,MemBufferedStream &s);
    static CH_Sound_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<CH_Sound,CH_Sound_Helper> CH_Sound_var;
  typedef _CORBA_ObjRef_OUT_arg<CH_Sound,CH_Sound_Helper > CH_Sound_out;

#endif
#define RolePlaying_CH_Sound_IntfRepoID "IDL:RolePlaying/CH_Sound:1.0"

  class CH_Sound :  public virtual ClientHandler {
  public:

    virtual MIMEList* SupportedMIME() = 0;
    typedef CH_Sound_var _var_type;
    typedef CH_Sound_ptr _ptr_type;
    static CH_Sound_ptr _duplicate(CH_Sound_ptr);
    static CH_Sound_ptr _narrow(CORBA::Object_ptr);
    static CH_Sound_ptr _nil();

    static inline size_t NP_alignedSize(CH_Sound_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_CH_Sound_IntfRepoID,29,initialoffset);
    }

    static inline void marshalObjRef(CH_Sound_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Sound_IntfRepoID,29,s);
    }

    static inline CH_Sound_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Sound_IntfRepoID,s);
      CH_Sound_ptr _result = RolePlaying::CH_Sound::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(CH_Sound_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_CH_Sound_IntfRepoID,29,s);
    }

    static inline CH_Sound_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_CH_Sound_IntfRepoID,s);
      CH_Sound_ptr _result = RolePlaying::CH_Sound::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    CH_Sound() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_CH_Sound_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~CH_Sound();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    CH_Sound(const CH_Sound&);
    CH_Sound &operator=(const CH_Sound&);
  };

  class _sk_CH_Sound :  public virtual _sk_ClientHandler, public virtual CH_Sound {
  public:

    _sk_CH_Sound() {}
    _sk_CH_Sound(const omniORB::objectKey& k);
    virtual ~_sk_CH_Sound();
    CH_Sound_ptr _this() { return CH_Sound::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual MIMEList* SupportedMIME() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Sound::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_CH_Sound (const _sk_CH_Sound&);
    _sk_CH_Sound &operator=(const _sk_CH_Sound&);
  };

  class _proxy_CH_Sound :  public virtual _proxy_ClientHandler, public virtual CH_Sound {
  public:

    _proxy_CH_Sound (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_CH_Sound_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_CH_Sound();
    virtual MIMEList* SupportedMIME();

  protected:

    _proxy_CH_Sound () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return CH_Sound::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_CH_Sound (const _proxy_CH_Sound&);
    _proxy_CH_Sound &operator=(const _proxy_CH_Sound&);
  };

  class _nil_CH_Sound :  public virtual _nil_ClientHandler,   public virtual CH_Sound {
  public:
    _nil_CH_Sound() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_CH_Sound();
    MIMEList* SupportedMIME() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      MIMEList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return CH_Sound::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class CH_Sound_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    CH_Sound_proxyObjectFactory () {}
    virtual ~CH_Sound_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static CH_Sound_ptr _nil() {
      if (!__nil_CH_Sound) {
        __nil_CH_Sound = new _nil_CH_Sound;
      }
      return __nil_CH_Sound;
    }
  private:
    static CH_Sound_ptr __nil_CH_Sound;
  };

#ifndef __RolePlaying_mClient__
#define __RolePlaying_mClient__
  class   Client;
  typedef Client* Client_ptr;
  typedef Client_ptr ClientRef;

  class Client_Helper {
    public:
    static Client_ptr _nil();
    static CORBA::Boolean is_nil(Client_ptr p);
    static void release(Client_ptr p);
    static void duplicate(Client_ptr p);
    static size_t NP_alignedSize(Client_ptr obj,size_t initialoffset);
    static void marshalObjRef(Client_ptr obj,NetBufferedStream &s);
    static Client_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Client_ptr obj,MemBufferedStream &s);
    static Client_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Client,Client_Helper> Client_var;
  typedef _CORBA_ObjRef_OUT_arg<Client,Client_Helper > Client_out;

#endif
#define RolePlaying_Client_IntfRepoID "IDL:RolePlaying/Client:1.0"

  class Client : public virtual omniObject, public virtual CORBA::Object {
  public:

#define RolePlaying_Client_NoHandlerAvailable_IntfRepoID "IDL:RolePlaying/Client/NoHandlerAvailable:1.0"

    class NoHandlerAvailable : public CORBA::UserException {
    public:

      
      NoHandlerAvailable() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NoHandlerAvailable(const NoHandlerAvailable &);
      NoHandlerAvailable & operator=(const NoHandlerAvailable &);
      virtual ~NoHandlerAvailable();
      virtual void _raise();
      static NoHandlerAvailable* _downcast(CORBA::Exception* e);
      static const NoHandlerAvailable* _downcast(const CORBA::Exception* e);
      static NoHandlerAvailable* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

    virtual ClientHandler_ptr  get_handler(const char*  which, CORBA::ULong  version) = 0;
    virtual void kick(const char*  reason,CORBA::Context_ptr ctxt) = 0;
    virtual void _0RL__request_object(const char*  type, CORBA::Object_ptr & o,CORBA::Context_ptr ctxt) = 0;
    void request_object ( const char *  type,
                                CORBA::Object_INOUT_arg  o,
                                CORBA::Context_ptr ctxt )
    {
      _0RL__request_object ( type, o._data, ctxt);
    }
    typedef Client_var _var_type;
    typedef Client_ptr _ptr_type;
    static Client_ptr _duplicate(Client_ptr);
    static Client_ptr _narrow(CORBA::Object_ptr);
    static Client_ptr _nil();

    static inline size_t NP_alignedSize(Client_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Client_IntfRepoID,27,initialoffset);
    }

    static inline void marshalObjRef(Client_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Client_IntfRepoID,27,s);
    }

    static inline Client_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Client_IntfRepoID,s);
      Client_ptr _result = RolePlaying::Client::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Client_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Client_IntfRepoID,27,s);
    }

    static inline Client_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Client_IntfRepoID,s);
      Client_ptr _result = RolePlaying::Client::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Client() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Client_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Client();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Client(const Client&);
    Client &operator=(const Client&);
  };

  class _sk_Client :  public virtual Client {
  public:

    _sk_Client() {}
    _sk_Client(const omniORB::objectKey& k);
    virtual ~_sk_Client();
    Client_ptr _this() { return Client::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual ClientHandler_ptr  get_handler(const char*  which, CORBA::ULong  version) = 0;
    virtual void kick(const char*  reason,CORBA::Context_ptr ctxt) = 0;
    virtual void request_object(const char*  type, CORBA::Object_ptr & o,CORBA::Context_ptr ctxt) = 0;
    virtual void _0RL__request_object(const char*  type, CORBA::Object_ptr & o,CORBA::Context_ptr ctxt) {
      request_object(type, o, ctxt);
    }
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Client::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Client (const _sk_Client&);
    _sk_Client &operator=(const _sk_Client&);
  };

  class _proxy_Client :  public virtual Client {
  public:

    _proxy_Client (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Client_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Client();
    virtual ClientHandler_ptr  get_handler(const char*  which, CORBA::ULong  version);
    virtual void kick(const char*  reason,CORBA::Context_ptr ctxt);
    virtual void _0RL__request_object(const char*  type, CORBA::Object_ptr & o,CORBA::Context_ptr ctxt);

  protected:

    _proxy_Client () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Client::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Client (const _proxy_Client&);
    _proxy_Client &operator=(const _proxy_Client&);
  };

  class _nil_Client :   public virtual Client {
  public:
    _nil_Client() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Client();
    ClientHandler_ptr  get_handler(const char*  which, CORBA::ULong  version){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      ClientHandler_ptr _0RL_result = 0;
      return _0RL_result;
#endif
    }

    void kick(const char*  reason,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

    void _0RL__request_object(const char*  type, CORBA::Object_ptr & o,CORBA::Context_ptr ctxt){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Client::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Client_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Client_proxyObjectFactory () {}
    virtual ~Client_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Client_ptr _nil() {
      if (!__nil_Client) {
        __nil_Client = new _nil_Client;
      }
      return __nil_Client;
    }
  private:
    static Client_ptr __nil_Client;
  };

#ifndef __RolePlaying_mSystem__
#define __RolePlaying_mSystem__
  class   System;
  typedef System* System_ptr;
  typedef System_ptr SystemRef;

  class System_Helper {
    public:
    static System_ptr _nil();
    static CORBA::Boolean is_nil(System_ptr p);
    static void release(System_ptr p);
    static void duplicate(System_ptr p);
    static size_t NP_alignedSize(System_ptr obj,size_t initialoffset);
    static void marshalObjRef(System_ptr obj,NetBufferedStream &s);
    static System_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(System_ptr obj,MemBufferedStream &s);
    static System_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<System,System_Helper> System_var;
  typedef _CORBA_ObjRef_OUT_arg<System,System_Helper > System_out;

#endif
#define RolePlaying_System_IntfRepoID "IDL:RolePlaying/System:1.0"

  class System : public virtual omniObject, public virtual CORBA::Object {
  public:

    virtual char* name() = 0;
    virtual char* description() = 0;
    typedef System_var _var_type;
    typedef System_ptr _ptr_type;
    static System_ptr _duplicate(System_ptr);
    static System_ptr _narrow(CORBA::Object_ptr);
    static System_ptr _nil();

    static inline size_t NP_alignedSize(System_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_System_IntfRepoID,27,initialoffset);
    }

    static inline void marshalObjRef(System_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_System_IntfRepoID,27,s);
    }

    static inline System_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_System_IntfRepoID,s);
      System_ptr _result = RolePlaying::System::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(System_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_System_IntfRepoID,27,s);
    }

    static inline System_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_System_IntfRepoID,s);
      System_ptr _result = RolePlaying::System::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    System() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_System_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~System();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    System(const System&);
    System &operator=(const System&);
  };

  class _sk_System :  public virtual System {
  public:

    _sk_System() {}
    _sk_System(const omniORB::objectKey& k);
    virtual ~_sk_System();
    System_ptr _this() { return System::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual char* name() = 0;
    virtual char* description() = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return System::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_System (const _sk_System&);
    _sk_System &operator=(const _sk_System&);
  };

  class _proxy_System :  public virtual System {
  public:

    _proxy_System (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_System_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_System();
    virtual char* name();
    virtual char* description();

  protected:

    _proxy_System () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return System::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_System (const _proxy_System&);
    _proxy_System &operator=(const _proxy_System&);
  };

  class _nil_System :   public virtual System {
  public:
    _nil_System() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_System();
    char* name() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    char* description() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return System::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class System_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    System_proxyObjectFactory () {}
    virtual ~System_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static System_ptr _nil() {
      if (!__nil_System) {
        __nil_System = new _nil_System;
      }
      return __nil_System;
    }
  private:
    static System_ptr __nil_System;
  };

#ifndef __RolePlaying_mGame__
#define __RolePlaying_mGame__
  class   Game;
  typedef Game* Game_ptr;
  typedef Game_ptr GameRef;

  class Game_Helper {
    public:
    static Game_ptr _nil();
    static CORBA::Boolean is_nil(Game_ptr p);
    static void release(Game_ptr p);
    static void duplicate(Game_ptr p);
    static size_t NP_alignedSize(Game_ptr obj,size_t initialoffset);
    static void marshalObjRef(Game_ptr obj,NetBufferedStream &s);
    static Game_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(Game_ptr obj,MemBufferedStream &s);
    static Game_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<Game,Game_Helper> Game_var;
  typedef _CORBA_ObjRef_OUT_arg<Game,Game_Helper > Game_out;

#endif
#define RolePlaying_Game_IntfRepoID "IDL:RolePlaying/Game:1.0"

  class Game : public virtual omniObject, public virtual CORBA::Object {
  public:

    typedef CORBA::ULong GameType;
    static _core_attr const CORBA::ULong GTMastered _init_in_cldecl_(  = 1 );
    static _core_attr const CORBA::ULong GTMultiPlayer _init_in_cldecl_(  = 2 );
    static _core_attr const CORBA::ULong GTMultiCharacter _init_in_cldecl_(  = 4 );
#define RolePlaying_Game_FeatureMissing_IntfRepoID "IDL:RolePlaying/Game/FeatureMissing:1.0"

    class FeatureMissing : public CORBA::UserException {
    public:

      
      FeatureMissing() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      FeatureMissing(const FeatureMissing &);
      FeatureMissing & operator=(const FeatureMissing &);
      virtual ~FeatureMissing();
      virtual void _raise();
      static FeatureMissing* _downcast(CORBA::Exception* e);
      static const FeatureMissing* _downcast(const CORBA::Exception* e);
      static FeatureMissing* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

#define RolePlaying_Game_AlreadyJoined_IntfRepoID "IDL:RolePlaying/Game/AlreadyJoined:1.0"

    class AlreadyJoined : public CORBA::UserException {
    public:

      
      AlreadyJoined() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      AlreadyJoined(const AlreadyJoined &);
      AlreadyJoined & operator=(const AlreadyJoined &);
      virtual ~AlreadyJoined();
      virtual void _raise();
      static AlreadyJoined* _downcast(CORBA::Exception* e);
      static const AlreadyJoined* _downcast(const CORBA::Exception* e);
      static AlreadyJoined* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

#define RolePlaying_Game_GameFull_IntfRepoID "IDL:RolePlaying/Game/GameFull:1.0"

    class GameFull : public CORBA::UserException {
    public:

      
      GameFull() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      GameFull(const GameFull &);
      GameFull & operator=(const GameFull &);
      virtual ~GameFull();
      virtual void _raise();
      static GameFull* _downcast(CORBA::Exception* e);
      static const GameFull* _downcast(const CORBA::Exception* e);
      static GameFull* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

#define RolePlaying_Game_NoAuthorization_IntfRepoID "IDL:RolePlaying/Game/NoAuthorization:1.0"

    class NoAuthorization : public CORBA::UserException {
    public:

      
      NoAuthorization() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NoAuthorization(const NoAuthorization &);
      NoAuthorization & operator=(const NoAuthorization &);
      virtual ~NoAuthorization();
      virtual void _raise();
      static NoAuthorization* _downcast(CORBA::Exception* e);
      static const NoAuthorization* _downcast(const CORBA::Exception* e);
      static NoAuthorization* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

    virtual char* name() = 0;
    virtual char* description() = 0;
    virtual System_ptr system_o() = 0;
    virtual GameType type() = 0;
    virtual char*  join(Client_ptr  cl) = 0;
    virtual void leave(const char*  id) = 0;
    typedef Game_var _var_type;
    typedef Game_ptr _ptr_type;
    static Game_ptr _duplicate(Game_ptr);
    static Game_ptr _narrow(CORBA::Object_ptr);
    static Game_ptr _nil();

    static inline size_t NP_alignedSize(Game_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_Game_IntfRepoID,25,initialoffset);
    }

    static inline void marshalObjRef(Game_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Game_IntfRepoID,25,s);
    }

    static inline Game_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Game_IntfRepoID,s);
      Game_ptr _result = RolePlaying::Game::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(Game_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_Game_IntfRepoID,25,s);
    }

    static inline Game_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_Game_IntfRepoID,s);
      Game_ptr _result = RolePlaying::Game::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    Game() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_Game_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~Game();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    Game(const Game&);
    Game &operator=(const Game&);
  };

  class _sk_Game :  public virtual Game {
  public:

    _sk_Game() {}
    _sk_Game(const omniORB::objectKey& k);
    virtual ~_sk_Game();
    Game_ptr _this() { return Game::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual char* name() = 0;
    virtual char* description() = 0;
    virtual System_ptr system_o() = 0;
    virtual GameType type() = 0;
    virtual char*  join(Client_ptr  cl) = 0;
    virtual void leave(const char*  id) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Game::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_Game (const _sk_Game&);
    _sk_Game &operator=(const _sk_Game&);
  };

  class _proxy_Game :  public virtual Game {
  public:

    _proxy_Game (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_Game_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_Game();
    virtual char* name();
    virtual char* description();
    virtual System_ptr system_o();
    virtual GameType type();
    virtual char*  join(Client_ptr  cl);
    virtual void leave(const char*  id);

  protected:

    _proxy_Game () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return Game::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_Game (const _proxy_Game&);
    _proxy_Game &operator=(const _proxy_Game&);
  };

  class _nil_Game :   public virtual Game {
  public:
    _nil_Game() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_Game();
    char* name() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    char* description() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    System_ptr system_o() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      System_ptr _0RL_result = 0;
      return _0RL_result;
#endif
    }

    GameType type() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      GameType _0RL_result = 0;
      return _0RL_result;
#endif
    }

    char*  join(Client_ptr  cl){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    void leave(const char*  id){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return Game::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class Game_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    Game_proxyObjectFactory () {}
    virtual ~Game_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static Game_ptr _nil() {
      if (!__nil_Game) {
        __nil_Game = new _nil_Game;
      }
      return __nil_Game;
    }
  private:
    static Game_ptr __nil_Game;
  };

#ifndef __RolePlaying_mGameList__
#define __RolePlaying_mGameList__
  class   GameList;
  typedef GameList* GameList_ptr;
  typedef GameList_ptr GameListRef;

  class GameList_Helper {
    public:
    static GameList_ptr _nil();
    static CORBA::Boolean is_nil(GameList_ptr p);
    static void release(GameList_ptr p);
    static void duplicate(GameList_ptr p);
    static size_t NP_alignedSize(GameList_ptr obj,size_t initialoffset);
    static void marshalObjRef(GameList_ptr obj,NetBufferedStream &s);
    static GameList_ptr unmarshalObjRef(NetBufferedStream &s);
    static void marshalObjRef(GameList_ptr obj,MemBufferedStream &s);
    static GameList_ptr unmarshalObjRef(MemBufferedStream &s);
  };
  typedef _CORBA_ObjRef_Var<GameList,GameList_Helper> GameList_var;
  typedef _CORBA_ObjRef_OUT_arg<GameList,GameList_Helper > GameList_out;

#endif
#define RolePlaying_GameList_IntfRepoID "IDL:RolePlaying/GameList:1.0"

  class GameList : public virtual omniObject, public virtual CORBA::Object {
  public:

    class GList_var;

    class GList : public _CORBA_Unbounded_Sequence_ObjRef<Game,_CORBA_ObjRef_Member<Game,Game_Helper>,Game_Helper > {
    public:
      typedef GList_var _var_type;
      inline GList() {}
      inline GList(const GList& seq)
        : _CORBA_Unbounded_Sequence_ObjRef<Game,_CORBA_ObjRef_Member<Game,Game_Helper>,Game_Helper >(seq) {}
      inline GList(CORBA::ULong max)
        : _CORBA_Unbounded_Sequence_ObjRef<Game,_CORBA_ObjRef_Member<Game,Game_Helper>,Game_Helper >(max) {}
      inline GList(CORBA::ULong max, CORBA::ULong len, Game_ptr* val, CORBA::Boolean rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef<Game,_CORBA_ObjRef_Member<Game,Game_Helper>,Game_Helper >(max, len, val, rel) {}
      inline GList& operator = (const GList& seq) {
        _CORBA_Unbounded_Sequence_ObjRef<Game,_CORBA_ObjRef_Member<Game,Game_Helper>,Game_Helper >::operator=(seq);
        return *this;
      };
    };

    class GList_out;

    class GList_var {
    public:
      typedef GList _Tseq;
      typedef GList_var _T_var;

      inline GList_var() : pd_seq(0) {}
      inline GList_var(_Tseq* s) : pd_seq(s) {}
      inline GList_var(const _T_var& sv) {
        if( sv.pd_seq ) {
          pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else
          pd_seq = 0;
      }
      inline ~GList_var() { if( pd_seq ) delete pd_seq; }

      inline _T_var& operator = (_Tseq* s) {
        if( pd_seq )  delete pd_seq;
        pd_seq = s;
        return *this;
      }
      inline _T_var& operator = (const _T_var& sv) {
        if( sv.pd_seq ) {
          if( !pd_seq )  pd_seq = new _Tseq;
          *pd_seq = *sv.pd_seq;
        } else if( pd_seq ) {
          delete pd_seq;
          pd_seq = 0;
        }
        return *this;
      }

      inline _CORBA_ObjRef_Member<Game,Game_Helper> operator [] (_CORBA_ULong i) {   return (*pd_seq)[i]; }
      inline _Tseq* operator -> () { return pd_seq; }
#if defined(__GNUG__) && __GNUG__ == 2 && __GNUC_MINOR__ == 7
      inline operator _Tseq& () const { return *pd_seq; }
#else
      inline operator const _Tseq& () const { return *pd_seq; }
      inline operator _Tseq& () { return *pd_seq; }
#endif

      inline const _Tseq& in() const { return *pd_seq; }
      inline _Tseq& inout() { return *pd_seq; }
      inline _Tseq*& out() { if (pd_seq) { delete pd_seq; pd_seq = 0; } return pd_seq; }
      inline _Tseq* _retn() { _Tseq* tmp = pd_seq; pd_seq = 0; return tmp; }

      friend class GList_out;

    private:
      _Tseq* pd_seq;
    };

    class GList_out {
    public:
      typedef GList _Tseq;
      typedef GList_var _T_var;

      inline GList_out(_Tseq*& s) : _data(s) { _data = 0; }
      inline GList_out(_T_var& sv)
        : _data(sv.pd_seq) { sv = (_Tseq*) 0; }
      inline GList_out(const GList_out& s) : _data(s._data) { }
      inline GList_out& operator=(const GList_out& s) { _data = s._data; return *this; }
      inline GList_out& operator=(_Tseq* s) { _data = s; return *this; }
      inline operator _Tseq*&() { return _data; }
      inline _Tseq*& ptr() { return _data; }
      inline _Tseq* operator->() { return _data; }
      inline _CORBA_ObjRef_Member<Game,Game_Helper> operator [] (_CORBA_ULong i) {   return (*_data)[i]; }
      _Tseq*& _data;

    private:
      GList_out();
      GList_out operator=( const _T_var&);
    };

#define RolePlaying_GameList_AlreadyRegistered_IntfRepoID "IDL:RolePlaying/GameList/AlreadyRegistered:1.0"

    class AlreadyRegistered : public CORBA::UserException {
    public:

      
      AlreadyRegistered() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      AlreadyRegistered(const AlreadyRegistered &);
      AlreadyRegistered & operator=(const AlreadyRegistered &);
      virtual ~AlreadyRegistered();
      virtual void _raise();
      static AlreadyRegistered* _downcast(CORBA::Exception* e);
      static const AlreadyRegistered* _downcast(const CORBA::Exception* e);
      static AlreadyRegistered* _narrow(CORBA::Exception* e);
      // NOTE: deprecated function from CORBA 2.2. Should use _downcast instead.
      size_t NP_alignedSize(size_t initialoffset) const;
      void operator>>= (NetBufferedStream &) const;
      void operator<<= (NetBufferedStream &);
      void operator>>= (MemBufferedStream &) const;
      void operator<<= (MemBufferedStream &);
      static _core_attr CORBA::Exception::insertExceptionToAny    insertToAnyFn;
      static _core_attr CORBA::Exception::insertExceptionToAnyNCP insertToAnyFnNCP;
    private:
      virtual CORBA::Exception* _NP_duplicate() const;
      virtual const char* _NP_mostDerivedTypeId() const;
    };

    virtual GList* list() = 0;
    virtual char*  _cxx_register(Game_ptr  g) = 0;
    virtual void unregister(const char*  id) = 0;
    typedef GameList_var _var_type;
    typedef GameList_ptr _ptr_type;
    static GameList_ptr _duplicate(GameList_ptr);
    static GameList_ptr _narrow(CORBA::Object_ptr);
    static GameList_ptr _nil();

    static inline size_t NP_alignedSize(GameList_ptr obj,size_t initialoffset) {
      return CORBA::AlignedObjRef(obj,RolePlaying_GameList_IntfRepoID,29,initialoffset);
    }

    static inline void marshalObjRef(GameList_ptr obj,NetBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_GameList_IntfRepoID,29,s);
    }

    static inline GameList_ptr unmarshalObjRef(NetBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_GameList_IntfRepoID,s);
      GameList_ptr _result = RolePlaying::GameList::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static inline void marshalObjRef(GameList_ptr obj,MemBufferedStream &s) {
      CORBA::MarshalObjRef(obj,RolePlaying_GameList_IntfRepoID,29,s);
    }

    static inline GameList_ptr unmarshalObjRef(MemBufferedStream &s) {
      CORBA::Object_ptr _obj = CORBA::UnMarshalObjRef(RolePlaying_GameList_IntfRepoID,s);
      GameList_ptr _result = RolePlaying::GameList::_narrow(_obj);
      CORBA::release(_obj);
      return _result;
    }

    static CORBA::Boolean _0RL_is_a(const char *base_repoId);

  protected:

    GameList() {
      if (!is_proxy())
        omniObject::PR_IRRepositoryId(RolePlaying_GameList_IntfRepoID);
      this->PR_setobj(this);
    }
    virtual ~GameList();
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id=0);

  private:

    GameList(const GameList&);
    GameList &operator=(const GameList&);
  };

  class _sk_GameList :  public virtual GameList {
  public:

    _sk_GameList() {}
    _sk_GameList(const omniORB::objectKey& k);
    virtual ~_sk_GameList();
    GameList_ptr _this() { return GameList::_duplicate(this); }
    void _obj_is_ready(CORBA::BOA_ptr boa) { boa->obj_is_ready(this); }
    CORBA::BOA_ptr _boa() { return CORBA::BOA::getBOA(); }
    void _dispose() { _boa()->dispose(this); }
    omniORB::objectKey _key();
    virtual GList* list() = 0;
    virtual char*  _cxx_register(Game_ptr  g) = 0;
    virtual void unregister(const char*  id) = 0;
    virtual CORBA::Boolean dispatch(GIOP_S &s,const char *op,CORBA::Boolean response);

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return GameList::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  private:
    _sk_GameList (const _sk_GameList&);
    _sk_GameList &operator=(const _sk_GameList&);
  };

  class _proxy_GameList :  public virtual GameList {
  public:

    _proxy_GameList (Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release) :
      omniObject(RolePlaying_GameList_IntfRepoID,r,key,keysize,profiles,release) {
        omni::objectIsReady(this);
    }
    virtual ~_proxy_GameList();
    virtual GList* list();
    virtual char*  _cxx_register(Game_ptr  g);
    virtual void unregister(const char*  id);

  protected:

    _proxy_GameList () {}

    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type) {
      return GameList::_widenFromTheMostDerivedIntf(repoId,is_cxx_type);
    }
  private:

    _proxy_GameList (const _proxy_GameList&);
    _proxy_GameList &operator=(const _proxy_GameList&);
  };

  class _nil_GameList :   public virtual GameList {
  public:
    _nil_GameList() : omniObject(omniObject::nilObjectManager()) { this->PR_setobj(0); }
    virtual ~_nil_GameList();
    GList* list() {
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      GList * _0RL_result = 0;
      return _0RL_result;
#endif
    }

    char*  _cxx_register(Game_ptr  g){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      char* _0RL_result = 0;
      return _0RL_result;
#endif
    }

    void unregister(const char*  id){
      throw CORBA::BAD_OPERATION(0,CORBA::COMPLETED_NO);
#ifdef NEED_DUMMY_RETURN
      // never reach here! Dummy return to keep some compilers happy.
      return;
#endif
    }

  protected:
    virtual void *_widenFromTheMostDerivedIntf(const char *repoId,CORBA::Boolean is_cxx_type_id) {
      return GameList::_widenFromTheMostDerivedIntf(repoId,is_cxx_type_id);
    }
  };

  class GameList_proxyObjectFactory : public CORBA::proxyObjectFactory {
  public:
    GameList_proxyObjectFactory () {}
    virtual ~GameList_proxyObjectFactory ();
    virtual const char *irRepoId() const;
    virtual CORBA::Object_ptr newProxyObject(Rope *r,CORBA::Octet *key,size_t keysize,IOP::TaggedProfileList *profiles,CORBA::Boolean release);
    virtual CORBA::Boolean is_a(const char *base_repoId) const;
    static GameList_ptr _nil() {
      if (!__nil_GameList) {
        __nil_GameList = new _nil_GameList;
      }
      return __nil_GameList;
    }
  private:
    static GameList_ptr __nil_GameList;
  };


_CORBA_MODULE_END


#undef _core_attr
#undef _dyn_attr

#endif // __roleplaying_hh__
